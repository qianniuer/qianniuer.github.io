[{"title":"JS中的call、apply、bind方法详解","date":"2016-10-12T08:37:46.000Z","path":"2016/10/12/JS中的call、apply、bind方法详解/","text":"call()、apply()、bind()都是函数对象的一个方法，它们的作用都是改变函数的调用对象。它的使用极大的简化了代码的调用。 一、方法定义call方法语法：call([thisObj[,arg1[, arg2[, [,.argN]]]]])定义：调用一个对象的一个方法，以另一个对象替换当前对象。说明：call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。arg1 … argN为被调用方法的传参。 apply方法语法：apply([thisObj[,argArray]])定义：应用某一对象的一个方法，用另一个对象替换当前对象。说明：apply的第一个参数thisObj和call方法的一样，第二个参数argArray为一个传参数组。thisObj如果未传，那么 Global 对象被用作 thisObj。 bind方法在ECMAScript5中扩展了叫bind的方法（IE6,7,8不支持）语法：bind([thisObj[,arg1[, arg2[, [,.argN]]]]])定义：应用某一对象的一个方法，用另一个对象替换当前对象。说明：bind的thisObj参数也和call方法一样，thisObj如果未传，那么 Global 对象被用作 thisObj。arg1 … argN可传可不传。如果不传，可以在调用的时候再传。如果传了，调用的时候则可以不传，调用的时候如果你还是传了，则不生效。例如：12345678910111213var person = &#123; name:\"tsrot\", age:24, sayHello:function(age)&#123; console.log(this.name); console.log(age); &#125;&#125;;var son = &#123; name:\"xieliqun\"&#125;;var boundFunc = person.sayHello.bind(son);boundFunc(25); // xieliqun 25 12var boundFunc = person.sayHello.bind(son,25);boundFunc(); // xieliqun 25 12var boundFunc = person.sayHello.bind(son,25);boundFunc(30); // xieliqun 25 二、call、apply、bind的区别1、call的arg传参需一个一个传，apply则直接传一个数组。123456function hello(name,age)&#123; console.log(name); console.log(age);&#125;hello.call(this,\"tsrot\",24);hello.apply(this,[\"tsrot\",24]); 2、call和apply直接执行函数，而bind需要再一次调用。12345678910111213var obj = &#123; x: 81,&#125;; var foo = &#123; getX: function() &#123; return this.x; &#125;&#125; console.log(foo.getX.bind(obj)()); //81console.log(foo.getX.call(obj)); //81console.log(foo.getX.apply(obj)); //81 三、运用场景实现继承12345678910111213function Animal(name) &#123; this.name = name; this.showName = function () &#123; console.log(this.name); &#125;&#125;function Cat(name) &#123; Animal.call(this, name); //Cat继承了Animal的showName方法&#125;var cat = new Cat('Black Cat');cat.showName(); //Black Cat 数组追加1234var array1 = [1 , 2 , 3, 5]; var array2 = [\"xie\" , \"li\" , \"qun\" , \"tsrot\"]; Array.prototype.push.apply(array1, array2);console.log(array1);//[1, 2, 3, 5, \"xie\", \"li\", \"qun\", \"tsrot\"] 获取数组中的最大值和最小值12345var num = [1,3,5,7,2,-10,11];var maxNum = Math.max.apply(Math, num);var minNum = Math.min.apply(Math, num);console.log(maxNum); //11console.log(minNum); //-10 将伪数组转化为数组12345678var fakeArr = &#123;0:'a',1:'b',length:2&#125;;var arr1 = Array.prototype.slice.call(fakeArr);console.log(arr1[0]); //avar arr2 = [].slice.call(fakeArr);console.log(arr2[0]); //aarr1.push(\"c\");console.log(arr1); //[\"a\", \"b\", \"c\"] 保存this变量12345678910111213141516171819202122// 正常情况下使用变量保存 this 值var foo = &#123; bar : 1, eventBind: function()&#123; var _this = this ; $('.someClass').on('click',function(event) &#123; /* Act on the event */ console.log(_this.bar); //1 &#125;); &#125;&#125;// 使用 bind 进行函数绑定var foo = &#123; bar : 1, eventBind: function()&#123; $('.someClass').on('click',function(event) &#123; /* Act on the event */ console.log(this.bar); //1 &#125;.bind(this)); &#125;&#125;","tags":[{"name":"原理","slug":"原理","permalink":"http://qianniuer.github.io/tags/原理/"}]},{"title":"React学习资源汇总","date":"2016-08-06T02:37:46.000Z","path":"2016/08/06/React学习资源汇总/","text":"React是如今最热门的前端框架，它设计思路独特，性能卓越，逻辑简单，受到了广泛开发者的喜爱。一旦接触她，你就会被她深深吸引。 我断断续续的学了将近两个月，今天终于有时间把自己学习React的一些学习资料总结一下。 React 官方 官网地址：http://facebook.github.io/react/ Github地址：https://github.com/facebook/react 设计思想学习React之前，我们先了解一下它的设计思想，它与如今其他热门的前端框架有什么不同？它能为我们的开发解决哪些痛点？ React 设计思想 React的设计哲学 - 简单之美 颠覆式前端UI开发框架:React 初学者入门文章可以结合一些简单demo去看文章，例如你在看阮一峰的React 入门实例教程时，可结合他写的入门demo，或官方给的demo。当然你也要边学习边自己去写一些简单demo，去改改别人写的一些React 项目。一定要多动手。 React 入门实例教程-阮一峰：建议先看demo 一看就懂的ReactJs入门教程（精华版） React 教程-菜鸟教程：安装那节好像有点错 React 入门，5个常用DEMO展示 如何学习React 给新手的 React&amp;Webpack 上手教程 ReactJS 傻瓜教程 React 最简单的入门应用项目 入门 demo 官方入门 demo：可结合官方的入门文档 入门 demo-阮一峰：结合入门文章 模仿知乎界面的一个简单React demo：结合 ReactJS中文基础视频教程-爱酷 入门视频教程一定要边看边写，不要囫囵吞枣的看一遍就好了。 React入门-慕课网 ReactJS中文基础视频教程-爱酷 ReactJS中文视频教程 React教程- 汇智网 入门实战视频了解React开发流程，作者的编码思路，写作规范。 React实战–打造画廊应用（上） React实战–打造画廊应用（下） ReactJS中文基础视频教程 构建实时聊天应用 开发文档开发其实不用详细去全看，在你做项目时，遇到不懂的就去查看一下文档，我认为这样效率更高一点。当然你有时间也可以一步步去阅读。 官方文档 中文文档 学习网站在学习中我们会遇到 一些问题，可以去社区或一些网站寻找答案，下面推荐一些好的React 社区和学习网站。 React中文社区 React 中文索引 React知识库 A quick start to React stack overflow 知乎 React 话题 segmentfault React 话题 React技术栈React是一款非常优秀的前端框架，你要发挥它完全的性能，你就要结合其他一些技术，例如webpack、redux、react-router等。 React 技术栈系列教程 百度母婴技术团队—基于Reactjs实现webapp Building a React Universal Blog App React为啥非得使用immutable.js React Server Side Rendering 解决 SPA 应用的 SEO 问题 webpack官方文档 Webpack 中文指南 webpack一小时快速入门 使用webpack轻松构建你的第一个react开发框架 入门Webpack，看这篇就够了:写的很不错，逐级深入，适合入门，有点长，耐心看完 react-router React Router 中文文档 React Router 官方 demo Redux官网 Redux 中文文档 Redux 官方 demo Redux 莞式教程 Redux 视频教程 redux 大法好 Flux 傻瓜教程 react+redux渲染性能优化原理 React开发社区 数据流管理架构之 Redux 介绍 React同构直出优化总结 前端路由实现与 react-router 源码分析 如何开发一个 Webpack Loader ( 一 ) 服务器端渲染实践小结 听说你需要这样了解 Redux 学习Redux刷新了我的前端App状态管理观 Learn React &amp; Webpack by building a hacker news front page 开发工具 react-devtools React DevTools 正式发布，完全支持 React Native redux-devtools Redux超酷的开发工具Redux-Devtools redux 常用中间件或工具 redux-thunk redux-gen redux-undo react-router-redux react-redux-form React 开源项目介绍一些国内外比较好的 React 开源项目。 国内： 阿里的 React 组件库 Ant Design 简易留言板 react-zhihu React的扫雷游戏 在线聊天室 使用React技术栈开发SPA 阔论留言评论 React版cnode社区 适合新手学习的Demo， React + react-router + webpack + babel + Node + express + mongodb 国外： Relax SoundRedux Gatsby isomorphic500 NuclearMail Picard React Color Sentry react-hn Perseus","tags":[{"name":"原理","slug":"原理","permalink":"http://qianniuer.github.io/tags/原理/"}]},{"title":"JavaScript中this指向","date":"2016-05-17T08:37:46.000Z","path":"2016/05/17/JavaScript中this指向/","text":"JavaScript中this指向 对于JavaScript初学者来说，this指针的指向问题一直是很混乱的问题。在不同的场景下，this会化身不同的对象。有一种观点认为，只有正确掌握了JavaScript 中的 this 关键字，才算是迈入了 JavaScript这门语言的门槛。在主流的面向对象的语言中（例如Java,C#等)，this 含义是明确且具体的，即指向当前对象。一般在编译期绑定。而JavaScript 中this 在运行期进行绑定的，这是JavaScript 中this 关键字具备多重含义的本质原因。 随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。 1、 指向window的隐式指向12345function sayHello()&#123; this.name = \"tsrot\"; console.log(\"hello \" + this.name);&#125;sayHello() //hello tsrot 此时的变量name相当于window.name，因为调用sayHello函数的对象为window，相当于window.sayHello()。和下面两种情况是一样的：12345var name = \"tsrot\";function sayHello()&#123; console.log(\"hello \" + this.name);&#125;sayHello(); //hello tsrot 下面的name相当于在window下赋值了两次，谁后面执行就取谁。如果把var name = “xieliqun”放到sayHello（）后面，此时输出的就是 hello xieliqun。123456var name = \"xieliqun\";function sayHello()&#123; this.name = \"tsrot\";&#125;sayHello(); console.log(\"hello \" + this.name); //hello tsrot 注：当函数在DOM上调用时，未传入this，此时，this也指向window。当传入this时，this指向当前DOM input，例如下面情况：123456&lt;input type=&quot;button&quot; value=&quot;click me&quot; onclick=&quot;sayHello()&quot;&gt;&lt;script&gt; function sayHello()&#123; console.log(&quot;hello &quot; + this.tagName); //hello undefined &#125;&lt;/script&gt; 123456&lt;input type=&quot;button&quot; value=&quot;click me&quot; onclick=&quot;sayHello(this.tagName)&quot;&gt;&lt;script&gt; function sayHello(tagName)&#123; console.log(&quot;hello &quot; + tagName); //hello INPUT &#125;&lt;/script&gt; 2、 指向当前对象的显式调用（1）、作为对象方法的调用函数还可以作为某个对象的方法调用，这时this就指这个上级对象。1234567function sayHello()&#123; console.log(\"hello \" + this.name);&#125;var o = &#123;&#125;;o.name = \"tsrot\";o.hello = sayHello;o.hello(); //hello tsrot （2）、作为构造函数调用所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。12345function sayHello()&#123; this.name = \"tsrot\";&#125;var o = new sayHello();console.log(\"hello \" + o.name); //hello tsrot 3、 指向当前对象的隐式调用（1） call、apply调用call（）、apply()都是函数对象的一个方法，它们的作用是改变函数的调用对象，它们的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。1234567function sayHello()&#123; console.log(\"hello \" + this.name);&#125;var o = &#123;&#125;;o.name = \"tsrot\";o.hello = sayHello;o.hello.apply(); //hello apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。如果把最后一行代码修改为12345// o.hello.apply(); //helloo.hello.apply(o); //hello tsroto.hello.apply(this); //hello tsroto.hello.call(o); //hello tsroto.hello.call(this); //hello tsrot 此时this就指向对象o了。 （2） 原生Function方法bind（）调用很多人不知道原生js也有bind（）方法，一直以为bind（）的方法只有jQuery有，我也是最近看别人博客知道的。其实原生的bind和jQuery的bind是不同的，原生的bind相当于apply和call。12345678var person = &#123; name:\"tsrot\", sayHello:function()&#123; console.log(\"你好，我是\"+this.name); &#125;&#125;var boundFunc = person.sayHello.bind(person,person.sayHello);setTimeout(boundFunc,5000); //5秒后输出 你好，我是tsrot ,[setTimeout 涉及一些执行栈的问题](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout)，或者简单的理解,在浏览器中setTimeout是window的属性。 下图代码中person.sayHello,相当于在window.person.sayHello，所以this指向window。12345678var person = &#123; name:\"tsrot\", sayHello:function()&#123; console.log(\"你好，我是\"+this.name); &#125;&#125;//var boundFunc = person.sayHello.bind(person,person.sayHello);setTimeout(person.sayHello,5000); //5秒后输出 你好，我是 用apply和call调用时，函数将立即执行12345678var person = &#123; name:\"tsrot\", sayHello:function()&#123; console.log(\"你好，我是\"+this.name); &#125;&#125;var boundFunc = person.sayHello.apply(person,person.sayHello);setTimeout(boundFunc,5000); //立即输出 你好，我是tsrot 4、 当this在构造函数有return时如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。123456function fn()&#123; this.name = \"tsrot\"; return &#123;&#125;;&#125;var o = new fn();console.log(o.name); //undefined 123456function fn()&#123; this.name = \"tsrot\"; return function()&#123;&#125;;&#125;var o = new fn();console.log(o.name); //undefined 当return null和undefined时123456function fn()&#123; this.name = \"tsrot\"; return null;&#125;var o = new fn();console.log(o.name); //tsrot 123456function fn()&#123; this.name = \"tsrot\"; return undefined;&#125;var o = new fn();console.log(o.name); //tsrot","tags":[{"name":"原理","slug":"原理","permalink":"http://qianniuer.github.io/tags/原理/"}]},{"title":"AJAX工作原理","date":"2016-05-03T01:03:46.000Z","path":"2016/05/03/Ajax工作原理/","text":"&gt; AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 一、ajax所包含的技术 大家都知道ajax并非一种新的技术，而是几种原有技术的结合体。它由下列技术组合而成。 使用CSS和XHTML来表示。 使用DOM模型来交互和动态显示。 使用XMLHttpRequest来和服务器进行异步通信。 使用javascript来绑定和调用。 在上面几中技术中，除了XmlHttpRequest对象以外，其它所有的技术都是基于web标准并且已经得到了广泛使用的，XMLHttpRequest虽然目前还没有被W3C所采纳，但是它已经是一个事实的标准，因为目前几乎所有的主流浏览器都支持它。 二、怎样创建ajaxAjax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。原生创建ajax可分为以下四步。 1、创建XMLHttpRequest对象所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。创建 XMLHttpRequest 对象的语法：1var xhr = new XMLHttpRequest(); 老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象：1var xhr = new ActiveXObject(\"Microsoft.XMLHTTP\"); 为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ：123456var xhr;if(XMLHttpRequest)&#123; xhr = new XMLHttpRequest();&#125;else&#123; xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");&#125; 2、准备请求初始化该XMLHttpRequest对象，接受三个参数：1xhr.open(method,url,async); 第一个参数表示请求类型的字符串，其值可以是GET或者POST。GET请求：1xhr.open(\"GET\",demo.php?name=tsrot&amp;age=24,true); POST请求：1xhr.open(\"POST\",demo.php,true); 第二个参数是要作为请求发送目标的URL。第三个参数是true或false，表示请求是以异步还是同步的模式发出。（默认为true，一般不建议为false） false：同步模式发出的请求会暂停所有javascript代码的执行，知道服务器获得响应为止，如果浏览器在连接网络时或者在下载文件时出了故障，页面就会一直挂起。 true：异步模式发出的请求，请求对象收发数据的同时，浏览器可以继续加载页面，执行其他javascript代码 3、发送请求1xhr.send(); 一般情况下，使用Ajax提交的参数多是些简单的字符串，可以直接使用GET方法将要提交的参数写到open方法的url参数中，此时send方法的参数为null或为空。 GET请求： 12xhr.open(\"GET\",demo.php?name=tsrot&amp;age=24,true);xhr.send(null); POST请求：如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定您希望发送的数据： 123xhr.open(\"POST\",demo.php,true);xhr.setRequestHeder(\"Content-Type\",\"application/x-www-form-urlencoded;charset=UTF-8\");xhr.send(\"name=\"+userName+\"&amp;age=\"+userAge); 4、处理响应12345xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; console.log(xhr.responseText); &#125;&#125; onreadystatechange 事件：当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当 readyState 改变时，就会触发 onreadystatechange 事件。 readyState属性：0：已经创建对象，但还没有调用open()方法。1：已经调用open()方法，但还没有发送请求。2：请求已经发送，标题和状态已经收到，并可用。3：接收到来自服务器的响应。4：接收完请求数据，表示已经完成请求。 status属性：200:”OK”404: 未找到页面 responseText：获得字符串形式的响应数据responseXML：获得 XML 形式的响应数据返回值一般为json字符串，可以用JSON.parse(xhr.responseText)转化为JSON对象。 5、完整例子demo.html123456789101112131415var xhr;if(XMLHttpRequest)&#123; xhr = new XMLHttpRequest();&#125;else&#123; xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");&#125;;xhr.open(\"GET\",\"./data.json\",true);xhr.send();xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; console.log(JSON.parse(xhr.responseText).name); &#125;&#125; data.json1234&#123; \"name\":\"tsrot\", \"age\":24&#125; 三、ajax应用场景 场景 1. 数据验证 场景 2. 按需取数据 场景 3. 自动更新页面 四、ajax优缺点优点：1、页面无刷新，用户体验好。2、异步通信，更加快的响应能力。3、减少冗余请求，减轻了服务器负担4、基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。 缺点：1、ajax干掉了back按钮，即对浏览器后退机制的破坏。2、存在一定的安全问题。3、对搜索引擎的支持比较弱。4、破坏了程序的异常机制。5、无法用URL直接访问。","tags":[{"name":"原理","slug":"原理","permalink":"http://qianniuer.github.io/tags/原理/"}]},{"title":"Arguments对象作用深度研究","date":"2016-04-16T08:37:46.000Z","path":"2016/04/16/Arguments对象作用深度研究/","text":"每个函数都会有一个Arguments对象实例arguments，它引用着函数的实参，可以用数组下标的方式”[]”引用arguments的元素。arguments.length为函数实参个数，arguments.callee引用函数自身。 Arguments对象介绍Arguments对象是一个伪数组对象，它有length属性，可以arguments[i]来访问对象中的元素，但它不能用数组的一些方法，例如push，pop，slice等。 Arguments的length属性Arguments的length属性，表示function函数实际所传参数的个数。函数名点length可以获取函数期望的传参个数。 1234567891011function argTest(a,b,c)&#123; var t = arguments.length; //实际传参个数 var e = argTest.length; //期望传参个数 console.log(t); console.log(e);&#125;argTest(11,12); //t=2,e=3argTest(11,12,13); //t=3,e=3argTest(11,12,13,14); //t=4,e=3 Arguments的参数访问Arguments对象的参数访问可以用arguments[i]来访问函数所传的参数。 1234567891011function argTest(a,b,c)&#123; var arg = []; for(var i=0;i&lt;arguments.length;i++)&#123; arg.push(arguments[i]); &#125; console.log(arg);&#125;argTest(11,12); //[11, 12]argTest(11,12,13); //[11, 12, 13]argTest(11,12,13,14); //[11, 12, 13, 14] Arguments的callee调用Arguments的callee属性可以调用函数本身，当函数正在执行时才可调用，可以实现方法的递归调用。 123456function argTest(a,b,c)&#123; var e = arguments.callee.toString(); console.log(e);&#125;argTest(); //打印出函数本身 Function对象caller属性Function对象的caller属性可以指向当前函数的调用者，当调用者函数正在执行时才可调用， 123456789101112131415161718192021function callerTest()&#123; if(callerTest.caller)&#123; var caller = callerTest.caller.toString(); console.log(caller); &#125;else&#123; console.log(\"no caller\") &#125;&#125;function handler()&#123; callerTest();&#125;function handlerToHandler()&#123; handler();&#125;callerTest(); //no callerhandler(); //返回调用者handler函数handlerToHandler(); //返回调用者handler函数 Arguments的作用方法重载方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。Javascript并没有重载函数的功能，但是Arguments对象能够模拟重载。 123456789101112131415//普通方法实现方法重载function test(a,b,c)&#123; if(a &amp;&amp; b &amp;&amp; c)&#123; console.log(a + b + c); &#125;else if(a &amp;&amp; b)&#123; console.log(a + b); &#125;else&#123; console.log(a); &#125;&#125;test(); //undefinedtest(11,12); //23test(11,12,13) //36 12345678910111213//Arguments对象实现方法重载function test()&#123; var sum = 0; for(var i=0;i&lt;arguments.length;i++)&#123; sum += arguments[i]; &#125; console.log(sum);&#125;test(); //0test(11,12); //23test(11,12,13); //36 12345678910111213//ES6实现方法重载function test(...nums)&#123; var sum = 0; for(var i=0;i&lt;nums.length;i++)&#123; sum += nums[i]; &#125; console.log(sum);&#125;test(); //0test(11,12); //23test(11,12,13); //36 递归调用这样的好处就是可以实现匿名函数的递归调用。 123456789101112//实现一个阶乘函数function factorial(n)&#123; if(n == 1)&#123; return 1; &#125;else&#123; n * arguments.callee(n-1); &#125;&#125;factorial(1); //1factorial(5); //120 不定参问题比如说，我想判断你传给我的一些数字的大小，取出最大的那个 123456789101112function max()&#123; var maxNum = Number.NEGATIVE_INFINITY;; for(var i=0;i&lt;arguments.length;i++)&#123; if(arguments[i]&gt; maxNum)&#123; maxNum = arguments[i]; &#125; &#125; return maxNum;&#125;max(1,2,3,11,4,10); //11max(2,-10,22,11); //22","tags":[{"name":"Arguments","slug":"Arguments","permalink":"http://qianniuer.github.io/tags/Arguments/"}]},{"title":"JS的原型和原型链","date":"2016-04-16T08:37:46.000Z","path":"2016/04/16/JS的原型和原型链/","text":"在JavaScript的使用过程中，我们经常会遇到prototype，可能了解一点，它是一个对象的原型，用来做原型继承的。这样去理解就有点不准确了，今天就让我们深入的去了解它。 了解一些概念在读这篇文章之前，你应该去在自己的脑海问几个问题：1、什么是原型？2、什么事原型链？3、prototype与__proto__有什么不同，有什么联系？4、constructor与面两个有什么联系，怎么用？ 如果你把上面这四个问题都解决了，那你就真正了解了JS的原型和原型链。接下来，咱们一个一个问题去解决。 什么是原型JavaScript 中，万物皆对象！但对象也是有区别的。分为普通对象和函数对象，Object ，Function 是JS自带的函数对象。每个对象都有原型（null和undefined除外），你可以把它理解为对象的默认属性和方法。 你可以把下面的代码在浏览器打印出来看一下。 1234567891011121314console.log(Object.prototype); //Object&#123;&#125;var o = new Object();console.log(o.prototype); //undefinedconsole.log(Array.prototype); //[Symbol(Symbol.unscopables): Object]console.log(Function.prototype); //function()&#123;&#125;function hello()&#123; console.log(\"hello\");&#125;hello.prototype = \"hello world\";console.log(hello.prototype); //hello world Object：Object是一个函数对象，Object的原型就是一个Object对象，它里面存在着一些对象的方法和属性，例如最常见的toString方法。 新建对象：用new Object或者{}建的对象是普通对象，它没有prototype属性，只有__proto__属性，它指向Object.prototype。 Array：Array也是一个函数对象，它的原型就是Array.prototype，它里面存在着一些数组的方法和属性，例如常见的push，pop等方法。 Function：Function也是一个函数对象，但它有点特殊，它的原型就是一个function空函数。 自定义函数：它的原型就是你给它指定的那个东西。如果你不指定，那它的原型就是一个Object.prototype。 什么是原型链在 javaScript 中，每个对象都有一个指向它的原型（prototype）对象的内部链接。这个原型对象又有自己的原型，直到某个对象的原型为 null 为止（也就是不再有原型指向），组成这条链的最后一环。这种一级一级的链结构就称为原型链（prototype chain）。 JavaScript 对象是动态的属性“包”（指其自己的属性）。JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依此层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。 12345678910var o = &#123; a:1, b:2&#125;;console.log(o.toString()); //不报错，o上没有toString方法，但是Object上有console.log(o.push(\"c\")); //报错，o上没有这个方法，Object上也没有这个方法。console.log(o.a); //1console.log(o.c); //undefined 当你用new Object或者直接定义一个对象时，它的原型链就是：o ==》 Object.prototype ==》 null但你访问o上没有的属性或方法时，JS会往Object.prototype上寻找该属性和方法。如果有则直接返回，如果没有，方法则报错，这个方法未定义，属性则返回undefined。 12345678910function Person(name)&#123; this.name = name;&#125;Person.prototype = &#123;age:24&#125;;var tsrot = new Person(\"tsrot\");console.log(tsrot.name); //tsrotconsole.log(tsrot.age); //24console.log(tsrot.toString()); //[object Object] 当你用构造函数（构造函数我们一般首字母大写）建立一个对象时，它的原型链就是：tsrot ==》 Person.prototype ==》 Object.prototype ==》 null如果没有定义Person.prototype这一环，则直接跳到下一环。 来点更复杂的。1234567891011121314151617function Parent()&#123; this.name = \"i am parent\";&#125;Parent.prototype = &#123;age:24&#125;;function Child()&#123; this.name = \"i am child\";&#125;Child.prototype = Object.create(Parent.prototype); //让Child的原型指向Parent的原型Child.prototype.constructor = Child; //把child的构造函数指向回来，否则它将指向Parent。虽然在这没什么影响，但要养成代码的严谨性var child = new Child();console.log(child.name); //i am childconsole.log(child.age); //24console.log(child.toString()); //[object Object] 当你需要父类的属性和方法时，你可以把它的原型指向父类的原型。此时的原型链就是：child ==》 Parent.prototype ==》 Object.prototype ==》 null 12345var arr = [1,2,3];console.log(arr); //[1,2,3]arr.push(4);console.log(arr); //[1,2,3,4] 数组也是一个对象，不过它是由Array构造函数new而来的，所以它的原型链就是：arr ==》 Array.prototype ==》 Object.prototype ==》 null 12345var fun = function()&#123; var hello = \"i am function\";&#125;console.log(fun.name); //fun fun是一个函数对象，它是由Function构造函数new而来的，所以它的原型链就是：fun ==》 Function.prototype ==》 Object.prototype ==》 nullfun它没有name属性，但是Function它有，所以这个name就是Function原型上的。 prototype与__proto__在Javascript中，每个函数都有一个原型属性prototype指向自身的原型，而由这个函数创建的对象也有一个__proto__属性指向这个原型，而函数的原型是一个对象（函数点prototype也是一个普通对象，Function.prototype除外,它是函数对象，但它很特殊，他没有prototype属性），所以这个对象也会有一个__proto__指向自己的原型，这样逐层深入直到Object对象的原型，这样就形成了原型链。普通对象没有prototype，但有__proto__属性。 1234567891011function f1()&#123;&#125;;console.log(f1.prototype) //Object&#123;&#125;console.log(typeof f1.prototype) //Objectconsole.log(typeof Function.prototype) // Function，这个特殊console.log(typeof Object.prototype) //Objectconsole.log(typeof Function.prototype.prototype) //undefined JS在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做__proto__的内置属性，用于指向创建它的函数对象的原型对象prototype。 普通对象的__proto__12345var o = &#123;name:\"tsrot\"&#125;;console.log(o.__proto__); //Object&#123;&#125;console.log(o.prototype); //undefinedconsole.log(o.__proto__ === Object.prototype); //true 构造对象的__proto__123456789101112131415161718192021function Parent()&#123; this.name = \"i am parent\";&#125;Parent.prototype = &#123;age:24&#125;;function Child()&#123; this.name = \"i am child\";&#125;Child.prototype = Object.create(Parent.prototype);Child.prototype.constructor = Child;var child = new Child();console.log(child.__proto__); //Object&#123;&#125;console.log(Child.prototype); //Object&#123;&#125;console.log(child.__proto__ === Child.prototype); //trueconsole.log(Parent.prototype.__proto__ === Object.prototype); //true 数组的__proto__1234567var arr = [1,2,3];console.log(arr.__proto__); //[Symbol(Symbol.unscopables): Object]console.log(Array.prototype); //[Symbol(Symbol.unscopables): Object]console.log(arr.__proto__ === Array.prototype); //true 函数的__proto__12345678910111213var fun = function()&#123; var hello = \"i am function\"&#125;fun.prototype = &#123;name:\"tsrot\"&#125;;console.log(fun.prototype); //Object &#123;name: \"tsrot\"&#125;console.log(fun.__proto__); //function()&#123;&#125;console.log(fun.prototype === fun.__proto__); //falseconsole.log(fun.__proto__ === Function.prototype); //true constructor属性原型对象prototype中都有个预定义的constructor属性，用来引用它的函数对象。这是一种循环引用： 123456789function Person(name)&#123; this.name = name;&#125;console.log(Person.prototype.constructor === Person); //trueconsole.log(Function.prototype.constructor === Function); //trueconsole.log(Object.prototype.constructor === Object); //true 用构造函数创建的对象，它的constructor属性就是它的构造函数。1234567function Person(name)&#123; this.name = name;&#125;var person = new Person();console.log(person.constructor === Person); //true 参考文章1、JavaScript Prototype Chains2、Understanding JavaScript Prototypes3、继承与原型链","tags":[{"name":"原理","slug":"原理","permalink":"http://qianniuer.github.io/tags/原理/"}]},{"title":"JavaScript闭包（closure）","date":"2016-04-16T08:37:46.000Z","path":"2016/04/16/JavaScript闭包(closure)/","text":"JavaScript变量分为全局变量和局部变量。Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量，而在函数外部自然无法读取函数内的局部变量。当你需要在函数外调用函数内的局部变量时，此时就要用到一些方法。这个过程就是闭包。 ###一、JavaScript为什么会有闭包这种东西JavaScript没有像其它后端语言一样可以直接定义一个变量可供其它外部函数调用的关键字或者方法。于是就产生了闭包这种东西。举个例子：123456//内部函数可以访问外部变量var name = \"tsrot\";function f1()&#123; console.log(name);&#125;f1(); //tsrot 12345//函数外部无法访问函数内部的局部变量function f2()&#123; var name = \"tsrot\"; //注意:不用var定义的变量，将会默认为全局变量&#125;console.log(name); //error undefined 如果是java，一个类的私有属性，可以通过公共的方法来获取，比如：123456class Person&#123; private String name; public String getName()&#123; return name; &#125; &#125; 二、闭包的概念闭包，官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。闭包的特点： 作为一个函数变量的一个引用，当函数返回时，其处于激活状态。 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。 我的理解就是：让函数外部能调用函数内部变量的一个过程就是闭包。举个例子：123456789function f1()&#123; var name1 = \"tsrot\"; function f2()&#123; return name1; &#125; return f2;&#125;var fun = f1(); //此时就访问到了name1的值console.log(fun()) //tsrot ###三、闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。举个例子：1234567891011function f1()&#123; var n = 0; function f2()&#123; n++; console.log(n); &#125; return f2; //注意此时应该写f2而不是f2()&#125;var fun = f1();fun(); //1fun(); //2 此时n就保存在了内存中 四、闭包的写法1、原型调用写法12345678910//在函数内部添加属性，然后在外部调用function Circle(r) &#123; this.r = r; &#125; Circle.PI = 3.14159; Circle.prototype.area = function() &#123; return Circle.PI * this.r * this.r; &#125;var c = new Circle(1.0); console.log(c.area()); 2、函数赋值调用写法12345678910var Circle = function() &#123; var obj = new Object(); obj.PI = 3.14159; obj.area = function(r) &#123; return this.PI * r * r; &#125; return obj; &#125;; var c = new Circle(); console.log(c.area(1.0)); 3、对象赋值调用写法（常用写法）123456var Circle = new Object(); Circle.PI = 3.14159; Circle.area = function(r) &#123; return this.PI * r * r; &#125;;consol.log(Circle.area(1.0)); 4、声明对象调用写法（比较好的一种写法）1234567var Circle=&#123; PI : 3.14159, area : function(r)&#123; return this.PI * r * r; &#125; &#125;; console.log(Circle.area(1.0)) 5、Function对象调用写法1234//比较少见的一种写法var Circle = new Function(\"this.PI = 3.14159;this.area = function( r ) &#123;return r*r*this.PI;&#125;\"); var c = new Circle();console.log(c.area(1.0)); 6、匿名函数调用写法（常用写法）12345(function(r)&#123; var PI = 3.14159; var area = PI * r * r; console.log(area);&#125;)(1.0) 7、函数返回值写法（常用写法）12345678function Circle(r)&#123; var PI = 3.14159; function area()&#123; return PI * r * r; &#125; return area();&#125;console.log(Circle(1.0)); 五、思考思考1：修改下面函数使之输出数组内元素？123456789function test()&#123; var arr = [1,2,3,4,5]; for(var i=0;i&lt;arr.length;i++)&#123; setTimeout(function()&#123; console.log(arr[i]); &#125;,1000); &#125;&#125;test(); 思考2：修改下面代码使之输出它想表达的结果 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id=&quot;list&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt;&lt;script&gt; var list = document.getElementById(&apos;list&apos;); var li = list.getElementsByTagName(&apos;li&apos;); for(var i=0;i&lt;li.length;i++)&#123; li[i].onclick = function()&#123; alert(li[i].innerHTML); //这里报错 &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 答案11234567891011function test()&#123; var arr = [1,2,3,4,5] for(var i=0;i&lt;5;i++)&#123; (function(i)&#123; setTimeout(function()&#123; console.log(arr[i]); &#125;,1000); &#125;)(i) &#125;&#125;test(); 答案2 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id=&quot;list&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt;&lt;script&gt; var list = document.getElementById(&apos;list&apos;); var li = list.getElementsByTagName(&apos;li&apos;); for(var i=0;i&lt;li.length;i++)&#123; (function(i)&#123; li[i].onclick = function()&#123; alert(li[i].innerHTML); &#125; &#125;)(i) &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"闭包","slug":"闭包","permalink":"http://qianniuer.github.io/tags/闭包/"}]}]