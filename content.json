[{"title":"Vue学习进阶（二）","date":"2017-04-06T15:37:46.000Z","path":"2017/04/06/Vue学习进阶（二）/","text":"安装###兼容Vue.js 不支持 IE8 及其以下版本，因为 Vue.js 使用了 IE8 不能模拟的 ECMAScript 5 特性。 Vue.js 支持所有兼容 ECMAScript 5 的浏览器。 ###更新日志每个版本的更新日志见：https://github.com/qianniuer/vue ##独立版本 直接下载并用 标签引入，Vue 会被注册为一个全局变量。重要提示：在开发时请用开发版本，遇到常见错误它会给出友好的警告。 ！！开发环境不要用最小压缩版，不然就失去了错误提示和警告! ####CDN推荐：unpkg, 会保持和 npm 发布的最新的版本一致。可以在 unpkg.com/vue/ 浏览 npm 包资源。也可以从 jsdelivr 或 cdnjs 获取，不过这两个服务版本更新可能略滞后。 ##NPM在用 Vue.js 构建大型应用时推荐使用 NPM 安装， NPM 能很好地和诸如 Webpack 或 Browserify 模块打包器配合使用。 Vue.js 也提供配套工具来开发单文件组件。12# 最新稳定版$ npm install vue ###独立构建vs运行时构建有两种构建方式，独立构建和运行构建。它们的区别在于前者包含模板编译器而后者不包含。 模板编译用于编译 Vue 模板字符串成纯 JavaScript 渲染函数。如果你想用 template 选项， 你需要编译。模板编译器的职责是将模板字符串编译为纯 JavaScript 的渲染函数。如果你想要在组件中使用 template 选项，你就需要编译器。 独立构建包含模板编译器并支持 template 选项。 它也依赖于浏览器的接口的存在，所以你不能使用它来为服务器端渲染。 运行时构建不包含模板编译器，因此不支持 template 选项，只能用 render 选项，但即使使用运行时构建，在单文件组件中也依然可以写模板，因为单文件组件的模板会在构建时预编译为 render 函数。运行时构建比独立构建要轻量30%，只有 17.14 Kb min+gzip大小。 默认 NPM 包导出的是 运行时 构建。为了使用独立构建，在 webpack 配置中添加下面的别名：12345resolve: &#123; alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.common.js&apos; &#125;&#125; 对于Browserify，可以添加一个别名到 package.json 中： 123&quot;browser&quot;: &#123; &quot;vue&quot;: &quot;vue/dist/vue.common&quot;&#125;, ###CSP环境有些环境，如 Google Chrome Apps ，强制应用内容安全策略 (CSP) ，不能使用 new Function() 对表达式求值。这时可以用 CSP 兼容版本。独立的构建取决于该功能编译模板，所以无法使用这些环境。 另一方面，运行时构建的是完全兼容 CSP 的。当通过 Webpack + vue-loader 或者 Browserify + vueify 构建时，在 CSP 环境中模板将被完美预编译到 render 函数中。 ##命令行工具 Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目：12345678# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 安装依赖，走你$ cd my-project$ npm install$ npm run dev CLI 工具假定用户对 Node.js 和相关构建工具有一定程度的了解。如果你是新手，我们强烈建议先在不用构建工具的情况下通读指南，熟悉 Vue 本身之后再研究 CLI。 使用npm在国内网络环境下会很慢，对于大陆用户，建议将 npm 的注册表源设置为国内的镜像，可以大幅提升安装速度。这样的话 以后使用npm的地方就用cnpm替换 ###安装cnpm 1npm install -g cnpm --registry=https://registry.npm.taobao.org ##开发版本 重要: Github 仓库的 /dist 文件夹只有在新版本发布时才会更新。如果想要使用 Github 上 Vue 最新的源码，你需要自己构建。 1234git clone https://github.com/vuejs/vue.git node_modules/vuecd node_modules/vuenpm installnpm run build ##Bower12# 最新稳定版本$ bower install vue ##AMD模块加载器 独立下载版本或通过 Bower 安装的版本已用 UMD 包装，因此它们可以直接用作 AMD 模块。 原文：http://vuejs.org/guide/installation.html","tags":[{"name":"Vue","slug":"Vue","permalink":"http://qianniuer.github.io/tags/Vue/"}]},{"title":"Vue学习进阶（三）","date":"2017-04-05T15:37:46.000Z","path":"2017/04/05/Vue学习进阶（三）/","text":"","tags":[{"name":"Vue","slug":"Vue","permalink":"http://qianniuer.github.io/tags/Vue/"}]},{"title":"W3C是如何制定web标准的？","date":"2017-02-11T00:21:46.000Z","path":"2017/02/11/W3C是如何制定web标准的？/","text":"首先，规范不是解决方案，规范只是对问题及其解决方案的抽象定义，描述其“应该（不应该）是什么，怎么做”等细节。具体的实现才是解决方案，一个问题或领域可能会有多个解决方案（比如多个浏览器及其多个版本的实现），但是所有的解决方案都应该遵循规范要求的接口实现，从而获得跨浏览器／平台的兼容性。以前这方面做得不够好，所以才有 web 开发曾经的“黑暗时期”。 制定一个标准要通过相当多的人员协作与支持，也要经历相当复杂的制定流程，所有的细节可以通过阅读 World Wide Web Consortium Process Document 文档获知。另外强烈推荐一个幻灯片：Standardization in W3C，耐心看完就会对 W3C 这个组织及其标准的制定过程有一个完整的认识了。 ###官方解释： 超文本标记语言（英文：HyperText Markup Language，HTML）是为“网页创建和其它可在网页浏览器中看到的信息”设计的一种标记语言。HTML被用来结构化信息——例如标题、段落和列表等等，也可用来在一定程度上描述文档的外观和语义。1982年由蒂姆·伯纳斯-李创建，由IETF用简化的SGML（标准通用标记语言）语法进行进一步发展的HTML，后来成为国际标准，由万维网联盟（W3C）维护。","tags":[{"name":"W3C","slug":"W3C","permalink":"http://qianniuer.github.io/tags/W3C/"}]},{"title":"史蒂夫·乔布斯十三句发人深省的经典名言","date":"2017-01-15T13:01:58.000Z","path":"2017/01/15/史蒂夫·乔布斯十三句发人深省的经典名言/","text":"转自 威锋网 史蒂夫·乔布斯，一个传奇的人物，他遗留下来的遗产不仅仅包含当今世界上最成功的科技公司，还有他那些曾经激励过无数人的直言不讳。日前，外媒《商业内幕》收录了史蒂夫·乔布斯 13 句经典的名言，我们再次来一起缅怀。 以下为文章全文： 史蒂夫·乔布斯，一个传奇的人物，他遗留下来的遗产不仅仅包含当今世界上最成功的科技公司，还有他那些曾经激励过无数人的直言不讳。日前，外媒《商业内幕》收录了史蒂夫·乔布斯 13 句经典的名言，我们再次来一起缅怀： 有关创造力 “Creativity is just connecting things. When you ask creative people how they did something, they feel a little guilty because they didn’t really do it, they just saw something. It seemed obvious to them after a while.” “创造力就是找到事物之间的联系。当你询问有创意的人他们是如何做事时，他们觉得有点内疚，因为他们并没有真的这么做，他们只是看到了其中一些关系。这种感觉在他们过后看来会很明显。” 有关死亡 “Remembering that you are going to die is the best way I know to avoid the trap of thinking you have something to lose. You are already naked. There is no reason not to follow your heart.” “记住，每个人终将会死去，这是我认为能够避免个人患得患失的最好方式，你已经赤裸裸地面对死亡，那就没有什么理由不去追随自己的心。” 有关卓越 “Be a yardstick of quality. Some people aren’t used to an environment where excellence is expected.” “要做一个质量标杆，有些人还不习惯面对一个卓越的环境。” 有关未来 “You can’t connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future. You have to trust in something – your gut, destiny, life, karma, whatever. This approach has never let me down, and it has made all the difference in my life.” “你无法在展望未来时串联点滴，你只能在回顾过去时将其升华。所以你要相信，这些点滴片段会在未来以某种方式串联起来。你要相信某种东西——直觉也好，命运也好，生命也好，或者因缘甚至是其他一切。这种方法从来没有让我失望，在我的生活中，这种意念造就了我的与众不同。” 有关坚持 “Your work is going to fill a large part of your life, and the only way to be truly satisfied is to do what you believe is great work. And the only way to do great work is to love what you do. If you haven’t found it yet, keep looking. Don’t settle. As with all matters of the heart, you’ll know when you find it. And, like any great relationship, it just gets better and better as the years roll on. So keep looking until you find it. Don’t settle.” “你的工作将占据你生活中的很大一部分，能够让你真正满意的唯一方法就是做你相信是伟大的工作，而唯一伟大的工作就是爱你所做的事。如果你还没有找到它，那么继续找，不要停。用心去找，你会知道何时能够找到它。如同任何伟大的关系一样，它只会在时间的证明之下越来越好，所以继续找，不要停，直到你找到它。” 有关追求 “Being the richest man in the cemetery doesn’t matter to me … Going to bed at night saying we’ve done something wonderful… that’s what matters to me.” “成为墓地里最有钱的人并不是我最在意的事……真正对我有意义的事，就是在晚上睡觉前说上一句‘我已经做了一些非常棒的事’……这才是我最在乎的。” 有关创新 “I’m as proud of many of the things we haven’t done as the things we have done. Innovation is saying no to a thousand things.” “我引以为豪的是，许多事情我们选择不去做，而许多事情我们又坚持去完成。创新就是对一千件事情说‘不’。” 有关目标 “I think if you do something and it turns out pretty good, then you should go do something else wonderful, not dwell on it for too long. Just figure out what’s next.” “我想如果你做了某些事，结果顺利圆满，那么你应该选择转去做别的事情，别专注在美好的事情上太久，要不断寻找下一个目标。” 有关失意 “Getting fired from Apple was the best thing that could have ever happened to me. The heaviness of being successful was replaced by the lightness of being a beginner again. It freed me to enter one of the most creative periods of my life.” “从苹果公司离职曾是我人生中最好的一件事，追求成功的沉重被创业者的轻松感觉所取代，这让我感觉如此自由，我重新进入人生中一个最有创造力的阶段。” 有关质量 “Quality is more important than quantity. One home run is much better than two doubles.” “质量比数量更重要，就像一个本垒打胜过两个双打。” 有关改变 “When I was 17, I read a quote that went something like: ‘If you live each day as if it was your last, someday you’ll most certainly be right.’ It made an impression on me, and since then, for the past 33 years, I have looked in the mirror every morning and asked myself: ‘If today were the last day of my life, would I want to do what I am about to do today?’ And whenever the answer has been ‘no’ for too many days in a row, I know I need to change something.” “我曾在 17 岁时读过这么一句名言：‘如果你把每一天当成自己人生的最后一天来过，那么将来某一天你会明白其中的真谛’，这句话令我印象深刻，此后的 33 年来，我每天早上都会对着镜子自问：‘如果今天是我生命的最后一天，我还会想去做我今天要去做的事吗？’，每当我心里的答案是‘不’时，我知道自己需要做出改变了。” 有关毅力 “I’m convinced that about half of what separates successful entrepreneurs from the non-successful ones is pure perseverance.” “我相信成功企业家和不成功企业家的区别有一半的原因在于纯粹的毅力。” 有关自省 “I want to put a ding in the universe.” “我希望可以在宇宙中安装一口警钟。”","tags":[{"name":"乔布斯","slug":"乔布斯","permalink":"http://qianniuer.github.io/tags/乔布斯/"},{"name":"语录","slug":"语录","permalink":"http://qianniuer.github.io/tags/语录/"}]},{"title":"window.name跨域详解","date":"2017-01-12T02:37:46.000Z","path":"2017/01/12/windowName跨域详解/","text":"window.name属性的神奇之处在于name 值在不同的页面（甚至不同域名）加载后依旧存在（如果没修改则值不会变化），并且可以支持非常长的 name 值（2MB）。并且window.name很方便。 用法介绍name 在浏览器环境中是一个全局/window对象的属性，且当在 frame 中加载新页面（可以是不同域的）时，name 的属性值依旧保持不变（只要不重新赋值）。name属性的值虽然不变，但对它的访问还是受到同域原则，不允许访问。所以我们要把iframe重新定向回原域，这样name的值也没变，并且可以访问了。 在最顶层，name 属性是不安全的，对于所有后续页面，设置在 name 属性中的任何信息都是可获得的。然而 windowName 模块总是在一个 iframe 中加载资源，并且一旦获取到数据，或者当你在最顶层浏览了一个新页面，这个 iframe 将被销毁，所以其他页面永远访问不到 window.name 属性。 函数封装为了方便以后的使用，我们把window.name进行一下封装。 123456789101112131415161718192021222324252627282930function proxy(url, func)&#123; var isFirst = true,//判断url第一次是否加载完 ifr = document.createElement('iframe'), loadFunc = function()&#123; if(isFirst)&#123; //加载完url后，重新定向回原域 ifr.contentWindow.location = 'about:blank'; isFirst = false; &#125;else&#123; //iframe回到原域后，获取name的值，执行回调函数，然后销毁iframe func(ifr.contentWindow.name); ifr.contentWindow.close(); document.body.removeChild(ifr); ifr.src = ''; ifr = null; &#125; &#125;; ifr.src = url; //第一次加载url ifr.style.display = 'none'; document.body.appendChild(ifr); //监听iframe是否加载，加载完执行loadFunc if(ifr.attachEvent)&#123; ifr.attachEvent('onload', loadFunc); &#125;else&#123; ifr.onload = loadFunc; &#125;&#125; 详细案例假设我现在在http://127.0.0.1:8080 ，我有一个页面叫做a.html，现在我想获取http://127.0.0.1:9090 上的b.html的数据。 a.html123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;script&gt;function proxy(url, func)&#123; var isFirst = true, ifr = document.createElement(&apos;iframe&apos;), loadFunc = function()&#123; if(isFirst)&#123; ifr.contentWindow.location = &apos;about:blank&apos;; isFirst = false; &#125;else&#123; func(ifr.contentWindow.name); ifr.contentWindow.close(); document.body.removeChild(ifr); ifr.src = &apos;&apos;; ifr = null; &#125; &#125;; ifr.src = url; ifr.style.display = &apos;none&apos;; document.body.appendChild(ifr); if(ifr.attachEvent)&#123; ifr.attachEvent(&apos;onload&apos;, loadFunc); &#125;else&#123; ifr.onload = loadFunc; &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; proxy(&apos;http://127.0.0.1:9090/b.html&apos;, function(data)&#123; console.log(JSON.parse(data).name); console.log(JSON.parse(data).age); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; b.html12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; var obj = &#123; name:&quot;tsrot&quot;, age:24 &#125;; window.name = JSON.stringify(obj);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"原理","slug":"原理","permalink":"http://qianniuer.github.io/tags/原理/"}]},{"title":"AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？","date":"2017-01-09T04:37:46.000Z","path":"2017/01/09/AMD、CMD规范区别？/","text":"##JavaSript模块化 在了解AMD，CMD规范前，还是需要先来简单地了解下什么是模块化，模块化开发？ 模块化是指在解决某一个复杂问题或者一系列的杂糅问题时，依照一种分类的思维把问题进行系统性的分解以之处理。模块化是一种处理复杂系统分解为代码结构更合理，可维护性更高的可管理的模块的方式。可以想象一个巨大的系统代码，被整合优化分割成逻辑性很强的模块时，对于软件是一种何等意义的存在。对于软件行业来说：解耦软件系统的复杂性，使得不管多么大的系统，也可以将管理，开发，维护变得“有理可循”。 还有一些对于模块化一些专业的定义为：模块化是软件系统的属性，这个系统被分解为一组高内聚，低耦合的模块。那么在理想状态下我们只需要完成自己部分的核心业务逻辑代码，其他方面的依赖可以通过直接加载被人已经写好模块进行使用即可。 首先，既然是模块化设计，那么作为一个模块化系统所必须的能力： 1. 定义封装的模块。 2. 定义新模块对其他模块的依赖。 3. 可对其他模块的引入支持。 好了，思想有了，那么总要有点什么来建立一个模块化的规范制度吧，不然各式各样的模块加载方式只会将局搅得更为混乱。那么在JavaScript中出现了一些非传统模块开发方式的规范 CommonJS的模块规范，AMD（Asynchronous Module Definition），CMD（Common Module Definition）等。 ##AMD 与 RequireJS ###AMD Asynchronous Module Definition，用白话文讲就是 异步模块定义，对于 JSer 来说，异步是再也熟悉不过的词了，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。 AMD规范定义了一个自由变量或者说是全局变量 define 的函数。 #####define( id?, dependencies?, factory ); AMD规范 https://github.com/amdjs/amdjs-api/wiki/AMD 第一个参数 id 为字符串类型，表示了模块标识，为可选参数。若不存在则模块标识应该默认定义为在加载器中被请求脚本的标识。如果存在，那么模块标识必须为顶层的或者一个绝对的标识。 第二个参数，dependencies ，是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。 第三个参数，factory，是一个需要进行实例化的函数或者一个对象。 创建模块标识为 alpha 的模块，依赖于 require， export，和标识为 beta 的模块 1234567define(&quot;alpha&quot;, [ &quot;require&quot;, &quot;exports&quot;, &quot;beta&quot; ], function( require, exports, beta )&#123; export.verb = function()&#123; return beta.verb(); // or: return require(&quot;beta&quot;).verb(); &#125;&#125;); 一个返回对象字面量的异步模块 1234567define([&quot;alpha&quot;], function( alpha )&#123; return &#123; verb : function()&#123; return alpha.verb() + 1 ; &#125; &#125;&#125;); 无依赖模块可以直接使用对象字面量来定义12345define( &#123; add : function( x, y )&#123; return x + y ; &#125;&#125; ); 类似与 CommonJS 方式定义12345define( function( require, exports, module)&#123; var a = require(&apos;a&apos;), b = require(&apos;b&apos;); exports.action = function()&#123;&#125;;&#125; ); #####require(); require API 介绍 https://github.com/amdjs/amdjs-api/wiki/require 在 AMD 规范中的 require 函数与一般的 CommonJS中的 require 不同。由于动态检测依赖关系使加载异步，对于基于回调的 require 需求强烈。 ######局部 与 全局 的require 局部的 require 需要在AMD模式中的 define 工厂函数中传入 require。 1234567define( [&apos;require&apos;], function( require )&#123; // ...&#125; );or：define( function( require, exports, module )&#123; // ...&#125; ); 局部的 require 需要其他特定的 API 来实现。全局的 require 函数是唯一全局作用域下的变量，像 define一样。全局的 require 并不是规范要求的，但是如果实现全局的 require函数，那么其需要具有与局部 require 函数 一样的以下的限定： 1. 模块标识视为绝对的，而不是相对的对应另一个模块标识。 2. 只有在异步情况下，require的回调方式才被用来作为交互操作使用。因为他不可能在同步的情况下通过 require(String) 从顶层加载模块。 依赖相关的API会开始模块加载。如果需要有互操作的多个加载器，那么全局的 reqiure 应该被加载顶层模块来代替。 1234567891011121314require(String)define( function( require )&#123; var a = require(&apos;a&apos;); // 加载模块a&#125; );require(Array, Function)define( function( require )&#123; require( [&apos;a&apos;, &apos;b&apos;], function( a,b )&#123; // 加载模块a b 使用 // 依赖 a b 模块的运行代码 &#125; ); &#125; );require.toUrl( Url )define( function( require )&#123; var temp = require.toUrl(&apos;./temp/a.html&apos;); // 加载页面&#125; ); amdjs 的API https://github.com/amdjs/amdjs-api/wiki","tags":[{"name":"RequireJS","slug":"RequireJS","permalink":"http://qianniuer.github.io/tags/RequireJS/"}]},{"title":"ES6部分方法点评（二）","date":"2017-01-09T04:37:46.000Z","path":"2017/01/09/ES6部分方法点评（二）/","text":"##template string template string（模板字符串），至ES6，javascript终于也能直接往字符串里插变量了。这用途嘛，说大不大，说小也不小；虽说不能实现比较复杂的例如if/for等语句就不能说是一个完整的模板引擎，但起码以后拼字符串就不用老写连接符+了不是？ name = 'guoyongfeng';12let age = 18;console.log(`$&#123;name&#125; want to drink $&#123;age&#125;`) ##Default（函数默认参数）喜大普奔！javascript终于能像其它语言一样在语言层面给形参设默认值了： 12345function f(x, y=12) &#123; // y is 12 if not passed (or passed as undefined) return x + y;&#125;f(3) == 15 ##class, extends, super一直以来，javascript的面向对象一般都是靠prototype，但毕竟跟其它语言中的class还是相差甚远的（当然硬要实现class也行，就是特麻烦），现在ES6终于从语言层面实现class了，鼓掌！！ 123456789101112131415161718192021class Animal &#123; constructor()&#123; this.type = &apos;animal&apos; &#125; says(say)&#123; console.log(this.type + &apos; says &apos; + say) &#125;&#125;let animal = new Animal()animal.says(&apos;hello&apos;) //animal says helloclass Cat extends Animal &#123; constructor()&#123; super() this.type = &apos;cat&apos; &#125;&#125;let cat = new Cat()cat.says(&apos;hello&apos;) //cat says hello ##Object.assign 这实际上就是jquery/zepto提供的extend方法，即把多个object合并到一起，这下又多了一个抛弃jquery/zepto的理由了： 1234567var target = &#123; a: 1 &#125;;var source1 = &#123; b: 2 &#125;;var source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);console.log(target); // &#123;a:1, b:2, c:3&#125;","tags":[{"name":"ES6","slug":"ES6","permalink":"http://qianniuer.github.io/tags/ES6/"}]},{"title":"ES6部分方法点评（一）","date":"2017-01-09T04:37:46.000Z","path":"2017/01/09/ES6部分方法点评（一）/","text":"一直以来，我对ES6都不甚感兴趣，一是因为在生产环境中使用ES5已是处处碰壁，其次则是只当这ES6是语法糖不曾重视。只是最近学习react生态，用起babel来转换jsx之余，也不免碰到诸多用上ES6的教程、案例，因此便稍作学习。这一学习，便觉得这语法糖实在是甜，忍不住尝鲜，于是记录部分自觉对自己有用的方法在此。 ##箭头函数(Arrow Functions) 箭头函数是一个典型的语法糖，即创造了一种新语法来简化javascript中函数的写法：123456// ES5var selected = allJobs.filter(function (job) &#123; return job.isSelected();&#125;);// ES6var selected = allJobs.filter(job =&gt; job.isSelected()); 上面这是函数只有一个形参的情况，下面列举函数有多个形参的情况： 123456// ES5var total = values.reduce(function (a, b) &#123; return a + b;&#125;, 0);// ES6var total = values.reduce((a, b) =&gt; a + b, 0); 语法大体是这样：([函数的形参，多个参数则以逗号分隔]) =&gt; [函数返回的值/表达式]另外，箭头函数也可以使用{}来引入函数块语句，不过这样的话其实就只是简写了function这一个单词了，意义不是很大，下面放个例子： 12345678910// ES5$(&quot;#confetti-btn&quot;).click(function (event) &#123; playTrumpet(); fireConfettiCannon();&#125;);// ES6$(&quot;#confetti-btn&quot;).click(event =&gt; &#123; playTrumpet(); fireConfettiCannon();&#125;); 对我来说，简写并不吸引我，吸引我的，是箭头函数的一个重要特性：箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。 123456789101112131415161718192021&#123; add: function(piece) &#123;&#125;, ... addAll: function addAll(pieces) &#123; var self = this; _.each(pieces, function (piece) &#123; self.add(piece); &#125;); &#125;, ...&#125;// ES6&#123; add: function(piece) &#123;&#125;, ... addAll: function addAll(pieces) &#123; _.each(pieces, piece =&gt; this.add(piece)); &#125;, ...&#125; ##let 自ES6，javascript开始拥有块级作用域，而let则是配合块级作用域，作为替代var的一个语法定义。有了块级作用域，再也不用担心临时变量污染到外层的变量了：1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; ##const const是用来定义常量的，一旦定义了就不可修改（一修改就报错）。用途嘛，也比较单一，就是定义一下配置项什么的，免得被团队里的愣头青写的代码给瞎改了。 ##destructuring destructuring是解构的意思，ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。来两个例子看看大家就明白了。12345678910111213141516&apos;use strict&apos;;// 数组的解构赋值let [foo, [[bar], baz]] = [1, [[2], 3]];console.log(foo); // 1console.log(bar); // 2console.log(baz); // 3// 对象的解构赋值var &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;console.log(foo); // &quot;aaa&quot;console.log(bar ); // &quot;bbb&quot;// 字符串的解构赋值const [a, b, c, d, e] = &apos;hello&apos;;console.log(a + b + c + e); // &apos;hello&apos; 跟箭头函数一样，也是个语法糖，那这是用在什么地方呢？请不要着急，听我细细道来：在我们封装函数的时候，如果形参较多，为了使用者不需要按顺序来传入参数，往往用一个object来承载所有的参数，例如这样： 1234567891011121314151617181920// 二逼青年写法function study(id, name, sex, grade, nickname, age, address) &#123; console.log(id); console.log(name); console.log(sex); console.log(grade); console.log(nickname); console.log(age); console.log(address);&#125;// 正常青年写法function study(params) &#123; console.log(params.id); console.log(params.name); console.log(params.sex); console.log(params.grade); console.log(params.nickname); console.log(params.age); console.log(params.address);&#125; 这种做法，虽说使用者是方便了，但写函数的人却麻烦了，每次用参数都要带上params.，或者再写个var id = params.id来让后续的使用方便一些。然而，有了destructuring后，我们有了更方便的写法： study(&#123;id, name, sex, grade, nickname, age, address&#125;) &#123;1234567891011121314151617 console.log(id); console.log(name); console.log(sex); console.log(grade); console.log(nickname); console.log(age); console.log(address); &#125;study(&#123; id: 1, name: &apos;林有德&apos;, sex: &apos;男&apos;, grade: &apos;一年级&apos;, nickname: &apos;布莱德&apos;, age: 12, address: &apos;木马号&apos;&#125;); 这样一来，使用者用起来很方便，而函数内部又直接解构赋值到各变量上，用起来也方便多了。","tags":[{"name":"ES6","slug":"ES6","permalink":"http://qianniuer.github.io/tags/ES6/"}]},{"title":"透彻掌握Promise的使用，读这篇就够了","date":"2017-01-03T04:03:46.000Z","path":"2017/01/03/透彻掌握Promise的使用，读这篇就够了/","text":"Promise的重要性我认为我没有必要多讲，概括起来说就是必须得掌握，而且还要掌握透彻。这篇文章的开头，主要跟大家分析一下，为什么会有Promise出现。 在实际的使用当中，有非常多的应用场景我们不能立即知道应该如何继续往下执行。最重要也是最主要的一个场景就是ajax请求。通俗来说，由于网速的不同，可能你得到返回值的时间也是不同的，这个时候我们就需要等待，结果出来了之后才知道怎么样继续下去。 1234567891011121314// 简单的ajax原生实现var url = &apos;https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2016-02-26/2016-06-10&apos;;var result;var XHR = new XMLHttpRequest();XHR.open(&apos;GET&apos;, url, true);XHR.send();XHR.onreadystatechange = function() &#123; if (XHR.readyState == 4 &amp;&amp; XHR.status == 200) &#123; result = XHR.response; console.log(result); &#125;&#125; 在ajax的原生实现中，利用了onreadystatechange事件，当该事件触发并且符合一定条件时，才能拿到我们想要的数据，之后我们才能开始处理数据。这样做看上去并没有什么麻烦，但是如果这个时候，我们还需要做另外一个ajax请求，这个新的ajax请求的其中一个参数，得从上一个ajax请求中获取，这个时候我们就不得不如下这样做：12345678910111213141516171819202122var url = &apos;https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2016-02-26/2016-06-10&apos;;var result;var XHR = new XMLHttpRequest();XHR.open(&apos;GET&apos;, url, true);XHR.send();XHR.onreadystatechange = function() &#123; if (XHR.readyState == 4 &amp;&amp; XHR.status == 200) &#123; result = XHR.response; console.log(result); // 伪代码 var url2 = &apos;http:xxx.yyy.com/zzz?ddd=&apos; + result.someParams; var XHR2 = new XMLHttpRequest(); XHR2.open(&apos;GET&apos;, url, true); XHR2.send(); XHR2.onreadystatechange = function() &#123; ... &#125; &#125;&#125; 当出现第三个ajax(甚至更多)仍然依赖上一个请求的时候，我们的代码就变成了一场灾难。这场灾难，往往也被称为回调地狱。 &gt;因此我们需要一个叫做Promise的东西，来解决这个问题。 除了回调地狱之外，还有一个非常重要的需求：为了我们的代码更加具有可读性和可维护性，我们需要将数据请求与数据处理明确的区分开来。上面的写法，是完全没有区分开，当数据变得复杂时，也许我们自己都无法轻松维护自己的代码了。这也是模块化过程中，必须要掌握的一个重要技能，请一定重视。 从前面几篇文中的知识我们可以知道，当我们想要确保某代码在谁谁之后执行时，我们可以利用函数调用栈，将我们想要执行的代码放入回调函数中。12345678910111213// 一个简单的封装function want() &#123; console.log(&apos;这是你想要执行的代码&apos;);&#125;function fn(want) &#123; console.log(&apos;这里表示执行了一大堆各种代码&apos;); // 其他代码执行完毕，最后执行回调函数 want &amp;&amp; want();&#125;fn(want); 利用回调函数封装，是我们在初学JavaScript时常常会使用的技能。 确保我们想要的代码压后执行，除了利用函数调用栈的执行顺序之外，我们还可以利用队列机制。1234567891011function want() &#123; console.log(&apos;这是你想要执行的代码&apos;);&#125;function fn(want) &#123; // 将想要执行的代码放入队列中，根据事件循环的机制，我们就不用非得将它放到最后面了，由你自由选择 want &amp;&amp; setTimeout(want, 0); console.log(&apos;这里表示执行了一大堆各种代码&apos;);&#125;fn(want); 如果浏览器已经支持了原生的Promise对象，那么我们就知道，浏览器的js引擎里已经有了Promise队列，这样就可以利用Promise将任务放在它的队列中去。123456789101112131415161718192021222324function want() &#123; console.log(&apos;这是你想要执行的代码&apos;);&#125;function fn(want) &#123; console.log(&apos;这里表示执行了一大堆各种代码&apos;); // 返回Promise对象 return new Promise(function(resolve, reject) &#123; if (typeof want == &apos;function&apos;) &#123; resolve(want); &#125; else &#123; reject(&apos;TypeError: &apos;+ want +&apos;不是一个函数&apos;) &#125; &#125;)&#125;fn(want).then(function(want) &#123; want();&#125;)fn(&apos;1234&apos;).catch(function(err) &#123; console.log(err);&#125;) 看上去变得更加复杂了。可是代码变得更加健壮，处理了错误输入的情况。 为了更好的往下扩展Promise的应用，这里需要先跟大家介绍一下Promsie的基础知识。 ##一、 Promise对象有三种状态，他们分别是： pending: 等待中，或者进行中，表示还没有得到结果 resolved(Fulfilled): 已经完成，表示得到了我们想要的结果，可以继续往下执行 rejected: 也表示得到结果，但是由于结果并非我们所愿，因此拒绝执行这三种状态不受外界影响，而且状态只能从pending改变为resolved或者rejected，并且不可逆。在Promise对象的构造函数中，将一个函数作为第一个参数。而这个函数，就是用来处理Promise的状态变化。1234new Promise(function(resolve, reject) &#123; if(true) &#123; resolve() &#125;; if(false) &#123; reject() &#125;;&#125;) 上面的resolve和reject都为一个函数，他们的作用分别是将状态修改为resolved和rejected。 ###二、 Promise对象中的then方法可以接收构造函数中处理的状态变化，并分别对应执行。then方法有2个参数，第一个函数接收resolved状态的执行，第二个参数接收reject状态的执行。12345678910111213141516function fn(num) &#123; return new Promise(function(resolve, reject) &#123; if (typeof num == &apos;number&apos;) &#123; resolve(); &#125; else &#123; reject(); &#125; &#125;).then(function() &#123; console.log(&apos;参数是一个number值&apos;); &#125;, function() &#123; console.log(&apos;参数不是一个number值&apos;); &#125;)&#125;fn(&apos;hahha&apos;);fn(1234); then方法的执行结果也会返回一个Promise对象。因此我们可以进行then的链式执行，这也是解决回调地狱的主要方式。123456789101112131415161718function fn(num) &#123; return new Promise(function(resolve, reject) &#123; if (typeof num == &apos;number&apos;) &#123; resolve(); &#125; else &#123; reject(); &#125; &#125;) .then(function() &#123; console.log(&apos;参数是一个number值&apos;); &#125;) .then(null, function() &#123; console.log(&apos;参数不是一个number值&apos;); &#125;)&#125;fn(&apos;hahha&apos;);fn(1234); then(null, function() {}) 就等同于catch(function() {}) ###三、Promise中的数据传递 大家自行从下面的例子中领悟吧。123456789101112131415161718192021222324252627var fn = function(num) &#123; return new Promise(function(resolve, reject) &#123; if (typeof num == &apos;number&apos;) &#123; resolve(num); &#125; else &#123; reject(&apos;TypeError&apos;); &#125; &#125;)&#125;fn(2).then(function(num) &#123; console.log(&apos;first: &apos; + num); return num + 1;&#125;).then(function(num) &#123; console.log(&apos;second: &apos; + num); return num + 1;&#125;).then(function(num) &#123; console.log(&apos;third: &apos; + num); return num + 1;&#125;);// 输出结果first: 2second: 3third: 4 OK，了解了这些基础知识之后，我们再回过头，利用Promise的知识，对最开始的ajax的例子进行一个简单的封装。看看会是什么样子。123456789101112131415161718192021222324252627var url = &apos;https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-02-26/2017-06-10&apos;;// 封装一个get请求的方法function getJSON(url) &#123; return new Promise(function(resolve, reject) &#123; var XHR = new XMLHttpRequest(); XHR.open(&apos;GET&apos;, url, true); XHR.send(); XHR.onreadystatechange = function() &#123; if (XHR.readyState == 4) &#123; if (XHR.status == 200) &#123; try &#123; var response = JSON.parse(XHR.responseText); resolve(response); &#125; catch (e) &#123; reject(e); &#125; &#125; else &#123; reject(new Error(XHR.statusText)); &#125; &#125; &#125; &#125;)&#125;getJSON(url).then(resp =&gt; console.log(resp)); 为了健壮性，处理了很多可能出现的异常，总之，就是正确的返回结果，就resolve一下，错误的返回结果，就reject一下。并且利用上面的参数传递的方式，将正确结果或者错误信息通过他们的参数传递出来。 现在所有的库几乎都将ajax请求利用Promise进行了封装，因此我们在使用jQuery等库中的ajax请求时，都可以利用Promise来让我们的代码更加优雅和简单。这也是Promise最常用的一个场景，因此我们一定要非常非常熟悉它，这样才能在应用的时候更加灵活。 ###四、Promise.all 当有一个ajax请求，它的参数需要另外2个甚至更多请求都有返回结果之后才能确定，那么这个时候，就需要用到Promise.all来帮助我们应对这个场景。 Promise.all接收一个Promise对象组成的数组作为参数，当这个数组所有的Promise对象状态都变成resolved或者rejected的时候，它才会去调用then方法。 1234567891011var url = &apos;https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-02-26/2017-06-10&apos;;var url1 = &apos;https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-03-26/2017-06-10&apos;;function renderAll() &#123; return Promise.all([getJSON(url), getJSON(url1)]);&#125;renderAll().then(function(value) &#123; // 建议大家在浏览器中看看这里的value值 console.log(value);&#125;) ###五、 Promise.race 与Promise.all相似的是，Promise.race都是以一个Promise对象组成的数组作为参数，不同的是，只要当数组中的其中一个Promsie状态变成resolved或者rejected时，就可以调用.then方法了。而传递给then方法的值也会有所不同，大家可以再浏览器中运行下面的例子与上面的例子进行对比。1234567function renderRace() &#123; return Promise.race([getJSON(url), getJSON(url1)]);&#125;renderRace().then(function(value) &#123; console.log(value);&#125;) 嗯，我所知道的，关于Promise的基础知识就这些了，如果还有别的，欢迎大家补充。 那么接下来，我们要结合三个不同的应用场景来让大家感受一下Promise在模块系统中如何使用。 123456789这里选择requirejs是因为学习成本最低，能够快速上手进行简单的运用。接下来的这些例子，会涉及到很多其他的知识，因此如果想要彻底掌握，一定要动手实践，自己试着完成一遍。我在github上创建了对应的项目，大家可以直接clone下来进行学习。这样学习效果会更好。项目地址： https://github.com/qianniuer/promiseApps往下阅读例子之前，请一定要对requirejs有一个简单的了解。requirejs中文文档 http://www.requirejs.cn/ 所有的html文件都放在根目录下。 pages: html直接引入的js libs: 常用的库 components: 针对项目自定义的模块 首先为了能够让require起作用，我们需要在html中引入require.js，写法如下：12// index.js为入口文件&lt;script data-main=&quot;./pages/index.js&quot; src=&quot;./libs/require.js&quot;&gt;&lt;/script&gt; 在入口的index.js中，我们可以对常用的模块进行映射配置，这样在引入时就可以少写一些代码。123456789101112// 具体的配置项的含义，请参阅require的中文文档requirejs.config(&#123; baseUrl: &apos;./&apos;, paths: &#123; jquery: &quot;./libs/jquery-3.2.0&quot;, API: &apos;./libs/API&apos;, request: &apos;./libs/request&apos;, calendar: &apos;./components/calendar&apos;, imageCenter: &apos;./components/imageCenter&apos;, dialog: &apos;./components/Dialog&apos; &#125;&#125;) 配置之后，那么我们在其他模块中，引入配置过的模块，就可以简单的这样写：1var $ = require(&apos;jquery&apos;); 如果不进行配置，也可以这样引入模块：1require(&apos;./components/button&apos;); 我们可以使用define定义一个模块：1234// 其他方式请参阅文档define(function(require) &#123;&#125;) 使用return可以直接对外提供方法：123456// 在其他模块通过require引入时得到的值，就是这里返回的值define(function(require) &#123; return &#123; a: 1 &#125;&#125;) OK，了解上面这些，应付基础的使用已经没有问题了。我们接下来重点总结第一个常用的应用场景：ajax。 关于ajax的简单使用和简单封装，我们在上面都已经讲过了，这里就不再多说，直接使用jquery封装好的方法即可。而我们需要处理的问题在于，如何有效的将ajax的数据请求和数据处理分别放在不同的模块中进行管理，这样做的主要目的在于降低后期维护成本，便于管理。 ##ajax的简单使用和简单封装 首先，将所有的url放在一个模块中统一处理。12345678// libs/API.jsdefine(function() &#123; return &#123; dayInfo: &apos;https://hq.tigerbrokers.com/fundamental/finance_calendar/get_day/2017-04-03&apos;, typeInfo: &apos;https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-03-26/2017-04-15&apos; &#125;&#125;)//在实际开发中，url并不是直接通过字符串就能直接确认的，某些url还需要通过参数拼接等，这个时候需要我们灵活处理。 第二步，将所有的数据请求这个动作放在同一个模块中统一管理。1234567891011121314151617181920212223// libs/request.jsdefine(function(require) &#123; var API = require(&apos;API&apos;); // 因为jQuery中的get方法也是通过Promise进行了封装，最终返回的是一个Promise对象，因此这样我们就可以将数据请求与数据处理放在不同的模块 // 这样我们就可以使用一个统一的模块来管理所有的数据请求 // 获取当天的信息 getDayInfo = function() &#123; return $.get(API.dayInfo); &#125; // 获取type信息 getTypeInfo = function() &#123; return $.get(API.typeInfo); &#125;; return &#123; getDayInfo: getDayInfo, getTypeInfo: getTypeInfo &#125;&#125;);//在这个模块中，我们还可以对拿到的数据进行一些你需要的过滤处理，确保最终返回给下一个模块的数据是能够直接使用的。 第三步：就是拿到数据并且处理数据了。1234567891011121314151617// components/calendar.jsdefine(function(require) &#123; var request = require(&apos;request&apos;); // 拿到数据之后，需要处理的组件，可以根据数据渲染出需求想要的样式 // 当然这里为了简化，就仅仅只是输出数据就行了，在实际中，拿到数据之后还要进行相应的处理 request.getTypeInfo() .then(function(resp) &#123; // 拿到数据，并执行处理操作 console.log(resp); &#125;) // 这样，我们就把请求数据，与处理数据分离开来，维护起来就更加方便了，代码结构也足够清晰&#125;)//这就是我所了解的处理ajax的比较好的一个方式，如果你有其他更好的方式也欢迎分享。 ##第二个应用场景就是图片加载的问题。在一些实际应用中，常常会有一些图片需要放置在某一个块中，比如头像，比如某些图片列表。可是源图片的尺寸可能很难保证长宽比例都是一致的，如果我们直接给图片设定宽高，就有可能导致图片变形。变形之后高大上的页面就直接垮掉了。 因此为了解决这个问题，我们需要一个定制的image组件来解决这个问题。我们期望图片能够根据自己的宽高比，合理的缩放，保证在这个块中不变形的情况下尽可能的显示更多的内容。 假如有一堆图片，如下：1234567891011121314151617&lt;section class=&quot;img-wrap&quot;&gt; &lt;div class=&quot;img-center&quot;&gt; ![](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1491191204817&amp;di=48ea9cde3319576ed6e0b6dc6c6b75b4&amp;imgtype=0&amp;src=http%3A%2F%2Fa.hiphotos.baidu.com%2Fzhidao%2Fpic%2Fitem%2F342ac65c103853438b3c5f8b9613b07ecb8088ad.jpg) &lt;/div&gt; &lt;div class=&quot;img-center&quot;&gt; ![](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1491191241712&amp;di=9dbd9c614b82f0b02c92c6e60875983a&amp;imgtype=0&amp;src=http%3A%2F%2Fpic5.qiyipic.com%2Fcommon%2F20130524%2F7dc5679567cd4243a0a41e5bf626ad77.jpg%3Fsrc%3Dfocustat_4_20130527_7) &lt;/div&gt; &lt;div class=&quot;img-center&quot;&gt; ![](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1491191271233&amp;di=0c9dd2677413beadcccd66b9d4598c6b&amp;imgtype=0&amp;src=http%3A%2F%2Fb.zol-img.com.cn%2Fdesk%2Fbizhi%2Fimage%2F4%2F960x600%2F1390442684896.jpg) &lt;/div&gt; &lt;div class=&quot;img-center&quot;&gt; ![](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1491191294538&amp;di=6474f3b560f2c100e62f118dde7e8d6c&amp;imgtype=0&amp;src=http%3A%2F%2Ff.hiphotos.baidu.com%2Fzhidao%2Fpic%2Fitem%2Fc9fcc3cec3fdfc03dfdfafcad23f8794a4c22618.jpg) &lt;/div&gt;&lt;/section&gt; 每一张图片都有一个包裹的div，这些div的宽高，就是我们期望图片能保持的宽高。 当图片宽度值过大时，我们期望图片的高度为100%，并且左右居中。当图片高度值过大时，我们期望图片的宽度为100%，并且上下居中。 根据这一点，我们来看看具体怎么实现。 首先是样式的定义很重要。123456789101112131415161718192021222324.img-center &#123; width: 200px; height: 150px; margin: 20px; overflow: hidden; position: relative;&#125;.img-center img &#123; display: block; position: absolute;&#125;.img-center img.aspectFill-x &#123; width: 100%; top: 50%; transform: translateY(-50%);&#125;.img-center img.aspectFill-y &#123; height: 100%; left: 50%; transform: translateX(-50%);&#125; 我分别定义了aspectFill-x与aspectFill-y，通过判断不同的宽高比，来决定将他们中的其中一个加入到img标签的class中去即可。 获取图片的原始宽高，需要等到图片加载完毕之后才能获取。而当图片已经存在缓存时，则有一个compete属性变成true。那么我们就可以根据这些基础知识，定义一个模块来处理这件事情。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// components/imageCenter.jsdefine(function(require) &#123; // 利用Promise封装一个加载函数，这里也是可以单独放在一个功能模块中进一步优化 var imageLoad = function(img) &#123; return new Promise(function(resolve, reject) &#123; if (img.complete) &#123; resolve(); &#125; else &#123; img.onload = function(event) &#123; resolve(event); &#125; img.onerror = function(err) &#123; reject(err); &#125; &#125; &#125;) &#125; var imageCenter = function(domList, mode) &#123; domList.forEach(function(item) &#123; var img = item.children[0]; var itemW = item.offsetWidth; var itemH = item.offsetHeight; var itemR = itemW / itemH; imageLoad(img).then(function() &#123; var imgW = img.naturalWidth; var imgH = img.naturalHeight; var imgR = imgW / imgH; var resultMode = null; switch (mode) &#123; // 这样写是因为期待未来可以扩展其他的展示方式 case &apos;aspectFill&apos;: resultMode = imgR &gt; 1 ? &apos;aspectFill-x&apos; : &apos;aspectFill-y&apos;; break; case &apos;wspectFill&apos;: resultMode = itemR &gt; imgR ? &apos;aspectFill-x&apos; : &apos;aspectFill-y&apos; break; default: &#125; $(img).addClass(resultMode); &#125;) &#125;) &#125; return imageCenter;&#125;) 那么在使用时，直接引入这个模块并调用imageCenter方法即可。1234// index.jsvar imageCenter = require(&apos;imageCenter&apos;);var imageWrapList = document.querySelectorAll(&apos;.img-center&apos;);imageCenter(imageWrapList, &apos;wspectFill&apos;); ###第三个应用场景，则是自定义弹窗的处理。因此自己专门定义一个常用的弹窗就变得非常有必要，这对于我们开发效率的提高非常有帮助。当然，我这里只是简单的写了一个简陋的，仅供参考。 我们期望的是利用Promise，当我们点击确认时，状态变成resolved，点击取消时，状态变成rejected。这样也方便将弹窗生成与后续的操作处理区分开来。 先定义一个Dialog模块。使用的是最简单的方式定义，应该不会有什么理解上的困难。主要提供了show和hide2个方法，用于展示和隐藏。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// components/Dialog.jsdefine(function(require) &#123; // 利用闭包的特性，判断是否已经存在实例 var instance; function Dialog(config) &#123; this.title = config.title ? config.title : &apos;这是标题&apos;; this.content = config.content ? config.content : &apos;这是提示内容&apos;; this.html = &apos;&lt;div class=&quot;dialog-dropback&quot;&gt;&apos; + &apos;&lt;div class=&quot;container&quot;&gt;&apos; + &apos;&lt;div class=&quot;head&quot;&gt;&apos;+ this.title +&apos;&lt;/div&gt;&apos; + &apos;&lt;div class=&quot;content&quot;&gt;&apos;+ this.content +&apos;&lt;/div&gt;&apos; + &apos;&lt;div class=&quot;footer&quot;&gt;&apos; + &apos;&lt;button class=&quot;cancel&quot;&gt;取消&lt;/button&gt;&apos; + &apos;&lt;button class=&quot;confirm&quot;&gt;确认&lt;/button&gt;&apos; + &apos;&lt;/div&gt;&apos; + &apos;&lt;/div&gt;&apos; + &apos;&lt;/div&gt;&apos; &#125; Dialog.prototype = &#123; constructor: Dialog, show: function() &#123; var _this = this; if (instance) &#123; this.destory(); &#125; $(this.html).appendTo($(document.body)); instance = this; return new Promise(function(resolve, reject) &#123; $(&apos;.dialog-dropback .cancel&apos;).on(&apos;click&apos;, function(e) &#123; _this.hide(); reject(e); &#125;) $(&apos;.dialog-dropback .confirm&apos;).on(&apos;click&apos;, function(e) &#123; _this.hide(); resolve(e); &#125;) &#125;) &#125;, destory: function() &#123; instance = null; $(&apos;.dialog-dropback .cancel&apos;).off(&apos;click&apos;); $(&apos;.dialog-dropback .confirm&apos;).off(&apos;click&apos;); $(&apos;.dialog-dropback&apos;).remove(); &#125;, hide: function() &#123; this.destory(); &#125; &#125; return function(config) &#123; return new Dialog(config); &#125;&#125;) 那么在另外一个模块中需要使用它时： 1234567891011121314define(function(require) &#123; var Dialog = require(&apos;dialog&apos;); $(&apos;button.aspect&apos;).on(&apos;click&apos;, function() &#123; Dialog(&#123; title: &apos;友情提示&apos;, content: &apos;外面空气不太好，你确定你要出门逛逛吗？&apos; &#125;).show().then(function() &#123; console.log(&apos;你点击了确认按钮.&apos;); &#125;).catch(function() &#123; console.log(&apos;你点击了取消按钮.&apos;); &#125;) &#125;)&#125;) 这三种场景就介绍完了，主要是需要大家通过源码来慢慢理解和揣摩。真正掌握之后，相信大家对于Promise在另外的场景中的使用也会变得得心应手。 最后总结一下，这篇文章，涉及到的东西，有点多。大概包括Promise基础知识，ajax基础知识，如何利用Promise封装ajax，如何使用require模块系统，如何在模块中使用Promise，并且对应的三个应用场景又各自有许多需要了解的知识，因此对于基础稍差的朋友来说，理解透彻了肯定会有一个比较大的进步。当然也会花费你更多的时间。 另外在我们的工作中还有一件非常重要的事情是需要我们持续去做的。那就是将常用的场景封装成为可以共用的模块，等到下次使用时，就可以直接拿来使用而节省非常多的开发时间。比如我这里对于img的处理，对于弹窗的处理，都是可以扩展成为一个通用的模块的。慢慢积累多了，你的开发效率就可以得到明显的提高，这些积累，也将会变成你的优势所在。","tags":[{"name":"Promise","slug":"Promise","permalink":"http://qianniuer.github.io/tags/Promise/"}]},{"title":"关于扑克，你知道多少？","date":"2016-11-27T00:56:58.000Z","path":"2016/11/27/关于扑克，你知道多少？/","text":"一付扑克牌共有54张，13种数字，每种数字有4张，也有4种花色，分别是黑桃、红桃、梅花和方块。代表一年中的春、夏、秋、冬四季。黑桃、梅花为黑色，即代表黑夜，红桃、方块为红色，即代表白天。 扑克牌中的字母也有特别的含义，比如说“A”在扑克牌中指“至尊”，意为扭转乾坤之王牌。“K”指“国王”，“Q”指“王后。“J”指的是“宫内的仆人杰克”。 扑克牌中的J、Q、K共12张，代表一年有12个月。除大、小王外，共52张，说明一年有52个星期。而扑克牌中每种花色共13张，说明每个季节正好13个星期。如果把扑克牌的点数相加，J作11点，Q作12点，K作13点，大、小王各作半点，正好365点，表示一年有365天。如果是闰年，把大、小王各作一点，刚好366点 （一）四种花色代表的意义扑克牌的四种花色代表的意义–扑克牌有四种花色，每一个花色代表一个季节，也就是一年有四个季节代表春、夏、秋、冬。而一个季度呢有91天，所以1+2+3+4+5+6+7+8+9+10+j+o+k=91。就是从1加到k等于91是一个季度的天数。再用91乘以一年4个季度正好等于364，差一天是一年的天数。可是每个花色有各代表哪个季节呢？黑桃代表什么？方片代表什么？草花代表什么？红桃代表什么？春季——黑桃（春天是第一季，黑桃在4样花色中也最大）／夏季——方片（夏天，天太热，）／秋天——草花（草花状像树-秋天是收获的季节）／冬天——红桃（红桃像火热的心） （二）扑克数字代表的意义。在占卜中，数字所代表的意义不仅与种牌有关，还依数字之差异而变化。A代表太阳。胸怀大志，进攻性，具有创造、积极性的男性性格特征。2代表月亮。包容力，想象力，审美力，协调力大女性性格特征。3代表木星。正义感，义务感，权威感、团结力和领导者的能力。4代表天王星。因观点，意见不同而产生不满而表示出叛逆，并且义务理想主义导致不服和分歧。5代表水星。表示寻求，探险的性情，具有坚强的意志。6代表金星。魅力四射，交际广泛，人际关系良好。7代表海王星。善于思考，喜欢旅游，并有获取知识、研究的雄心。8代表土星。孤独，容易走极端，对自身的成功与幸福热切关注，利己主义的性格。9代表火星。如火的激情，超凡的勇气与强大的攻击力，属于可怕型性格。 （三）扑克牌所代表的意义扑克牌若去除鬼牌，则剩下五十二张，这五十二张正代表了一年有五十二周，而那鬼牌即代表了闰年。 接着，我们来看看扑克牌中所蕴含的其他意思。扑克牌有红心、方块、梅花、黑桃四种图案，分别代表了一年有春、夏、秋、冬四个季节；一季有十三周，所以从A到K共有十三张；一年有十二个月，所以图神有十二张：一年有三百六十五天，所以扑克牌上的数字全部加起来是三百六十五；另外，一年中有一半是白天、一半是黑夜，所以扑克牌也是一半红的，一半黑的。扑克牌是历法的缩影：54张牌中，2张是副牌，分别代表太阳与月亮，其它52张牌表示一年有52个星期。一年四季春、夏、秋、冬分别用桃、心、梅、方块来表示，其中黑桃、梅花代表黑夜、红心、方块代表白昼。每个季度有13个星期，扑克牌每个花色正好为13张牌。每个季度平均为91天，13张牌的点数加起来正好是91点。扑克牌中的J、Q、K共有12张，表示一年有12个月。4种花色点数之和是364，再加大王的一点为365，是一年的天数，若再加小王一点为366，正好是闰年的天数。另外，扑克牌中的四个花色还有不同寓意：黑桃表示橄榄叶，象征和平；红桃是心形，表示智慧；梅花傲霜雪，表现坚强；方块表示钻石，意味着财富。四种花色是人们在一年中的美好愿望。扑克牌分为四种花色：黑桃、方块、梅花和红桃。各国人民都以本国民族文化对四种花色给予不同的文化阐述。法国人将四种花色理解为矛、方形、丁香叶和红心；德国人把四种花色理解为树叶、铃铛、橡树果和红心；意大利人将四种花色理解为宝剑、硬币、拐杖和酒杯；瑞士人将四种花色理解为橡树果、铃铛、花朵和盾牌；英国人则将四种花色理解为铲子、钻石、三叶草和红心。比较集中的说法有以下两种：一说是这四种花色代表当时社会的四种主要行业，其中黑桃代表长矛，象征军人；梅花代表三叶花，象征农业；方块代表工匠使用的砖瓦；红桃代表红心，象征牧师。另一说是这四种花色来源于欧洲古代占卜所用器物的图样，其中黑桃代表橄榄叶，象征和平；梅花为三叶草，意味着幸运；方块呈钻石形状，象征财富；而红桃为红心型，象征智慧和爱情。扑克牌的54张模式解释起来也非常奇妙：大王代表太阳、小王代表月亮，其余52张牌代表一年中的52个星期；红桃、方块、梅花、黑桃四种花色分别象征着春、夏、秋、冬四个季节；每种花色有13张牌，表示每个季节有13个星期。如果把J、Q、K当作11、12、13点，大王、小王为半点，一副扑克牌的总点数恰好是365点。而闰年把大、小王各算为1点，共366点。专家普遍认为，以上解释并非巧合，因为扑克牌的设计和发明与星相、占卜以及天文、历法有着千丝万缕的联系。","tags":[{"name":"思考","slug":"思考","permalink":"http://qianniuer.github.io/tags/思考/"},{"name":"扑克","slug":"扑克","permalink":"http://qianniuer.github.io/tags/扑克/"}]},{"title":"html5 API postMessage跨域详解","date":"2016-11-12T08:37:46.000Z","path":"2016/11/12/html5 API postMessage跨域详解/","text":"window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。 准备跨域是什么，我就不详细解释了，我相信你在看这篇文章前就已经了解的差不多了。现在我就直接进入实战阶段。 两个服务器： http://127.0.0.1:8080 http://127.0.0.1:9090 先建立两个不同域的测试环境。我用http-server（一个node服务器插件）建立了两个不同端口的本地服务器。 两个页面： a.html b.html 在http://127.0.0.1:8080中新建a.html，在http://127.0.0.1:9090中新建b.html。 数据发送postMessage允许用户在两个窗口或frame之间传递数据，无论这个window对象是不是同源都能发送。 首先我们先在a.html中建立一个iframe。 1&lt;iframe src=&quot;http://127.0.0.1:9090/b.html&quot; frameborder=&quot;0&quot; id=&quot;ifra&quot; name=&quot;postIframe&quot; onload=&quot;messageLoad()&quot;&gt;&lt;/iframe&gt; 当iframe加载完时，发送数据 1234567function messageLoad()&#123; var url = \"http://127.0.0.1:9090\"; window.postIframe.postMessage(\"给我tsort的信息\",url);&#125; postMessage包括两个参数data和url，data为发送的数据，url为发送地址。 数据接收html5新增了onmessage事件，它和onclick之类用法差不多。当窗口或frame接收到postMessage发送过来的数据时，将触发onmessage事件。 1234window.onmessage = function(e)&#123; e = e || event; alert(e.data);&#125; 该事件接收一个event对象，这个对象有三个属性，分别为source，origin，data。 source： 消息源，消息的发送窗口/iframe。origin：消息源的URI(可能包含协议、域名和端口)，用来验证数据源。data：发送方发送给接收方的数据。 完整例子这个例子是这样的，a页面中有一个iframe，这个iframe是另一个域的b页面。当b加载完的时候，让它去给iframe里的页面发送一条信息。然后里面的页面立即回复已经接收到信息，然后再等三秒，回复a所请求的数据。 a.html 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe src=&quot;http://127.0.0.1:9090/b.html&quot; name=&quot;postIframe&quot; onload=&quot;messageLoad()&quot;&gt;&lt;/iframe&gt;&lt;script&gt; function messageLoad()&#123; var url = &quot;http://127.0.0.1:9090&quot;; window.postIframe.postMessage(&quot;给我tsort的信息&quot;,url); //发送数据 &#125; window.onmessage = function(e)&#123; e = e || event; console.log(e.data); //接收b返回的数据，在控制台有两次输出 &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; b.html 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; window.onmessage = function(e)&#123; e = e || event; alert(e.data); //立即弹出a发送过来的数据 e.source.postMessage(&quot;好的，请稍等三秒！&quot;,e.origin); //立即回复a var postData = &#123;name:&quot;tsrot&quot;,age:24&#125;; var strData = JSON.stringify(postData); //json对象转化为字符串 setTimeout(function()&#123; e.source.postMessage(strData,e.origin); &#125;,3000); //3秒后向a发送数据 &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"原理","slug":"原理","permalink":"http://qianniuer.github.io/tags/原理/"}]},{"title":"JS中的call、apply、bind方法详解","date":"2016-10-12T08:37:46.000Z","path":"2016/10/12/JS中的call、apply、bind方法详解/","text":"call()、apply()、bind()都是函数对象的一个方法，它们的作用都是改变函数的调用对象。它的使用极大的简化了代码的调用。 一、方法定义call方法语法：call([thisObj[,arg1[, arg2[, [,.argN]]]]])定义：调用一个对象的一个方法，以另一个对象替换当前对象。说明：call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。arg1 … argN为被调用方法的传参。 apply方法语法：apply([thisObj[,argArray]])定义：应用某一对象的一个方法，用另一个对象替换当前对象。说明：apply的第一个参数thisObj和call方法的一样，第二个参数argArray为一个传参数组。thisObj如果未传，那么 Global 对象被用作 thisObj。 bind方法在ECMAScript5中扩展了叫bind的方法（IE6,7,8不支持）语法：bind([thisObj[,arg1[, arg2[, [,.argN]]]]])定义：应用某一对象的一个方法，用另一个对象替换当前对象。说明：bind的thisObj参数也和call方法一样，thisObj如果未传，那么 Global 对象被用作 thisObj。arg1 … argN可传可不传。如果不传，可以在调用的时候再传。如果传了，调用的时候则可以不传，调用的时候如果你还是传了，则不生效。例如：12345678910111213var person = &#123; name:\"tsrot\", age:24, sayHello:function(age)&#123; console.log(this.name); console.log(age); &#125;&#125;;var son = &#123; name:\"xieliqun\"&#125;;var boundFunc = person.sayHello.bind(son);boundFunc(25); // xieliqun 25 12var boundFunc = person.sayHello.bind(son,25);boundFunc(); // xieliqun 25 12var boundFunc = person.sayHello.bind(son,25);boundFunc(30); // xieliqun 25 二、call、apply、bind的区别1、call的arg传参需一个一个传，apply则直接传一个数组。123456function hello(name,age)&#123; console.log(name); console.log(age);&#125;hello.call(this,\"tsrot\",24);hello.apply(this,[\"tsrot\",24]); 2、call和apply直接执行函数，而bind需要再一次调用。12345678910111213var obj = &#123; x: 81,&#125;; var foo = &#123; getX: function() &#123; return this.x; &#125;&#125; console.log(foo.getX.bind(obj)()); //81console.log(foo.getX.call(obj)); //81console.log(foo.getX.apply(obj)); //81 三、运用场景实现继承12345678910111213function Animal(name) &#123; this.name = name; this.showName = function () &#123; console.log(this.name); &#125;&#125;function Cat(name) &#123; Animal.call(this, name); //Cat继承了Animal的showName方法&#125;var cat = new Cat('Black Cat');cat.showName(); //Black Cat 数组追加1234var array1 = [1 , 2 , 3, 5]; var array2 = [\"xie\" , \"li\" , \"qun\" , \"tsrot\"]; Array.prototype.push.apply(array1, array2);console.log(array1);//[1, 2, 3, 5, \"xie\", \"li\", \"qun\", \"tsrot\"] 获取数组中的最大值和最小值12345var num = [1,3,5,7,2,-10,11];var maxNum = Math.max.apply(Math, num);var minNum = Math.min.apply(Math, num);console.log(maxNum); //11console.log(minNum); //-10 将伪数组转化为数组12345678var fakeArr = &#123;0:'a',1:'b',length:2&#125;;var arr1 = Array.prototype.slice.call(fakeArr);console.log(arr1[0]); //avar arr2 = [].slice.call(fakeArr);console.log(arr2[0]); //aarr1.push(\"c\");console.log(arr1); //[\"a\", \"b\", \"c\"] 保存this变量12345678910111213141516171819202122// 正常情况下使用变量保存 this 值var foo = &#123; bar : 1, eventBind: function()&#123; var _this = this ; $('.someClass').on('click',function(event) &#123; /* Act on the event */ console.log(_this.bar); //1 &#125;); &#125;&#125;// 使用 bind 进行函数绑定var foo = &#123; bar : 1, eventBind: function()&#123; $('.someClass').on('click',function(event) &#123; /* Act on the event */ console.log(this.bar); //1 &#125;.bind(this)); &#125;&#125;","tags":[{"name":"原理","slug":"原理","permalink":"http://qianniuer.github.io/tags/原理/"}]},{"title":"ES6新特性：类(Class)和继承(Extends)","date":"2016-10-04T01:42:46.000Z","path":"2016/10/04/ES6新特性5：类(Class)和继承(Extends)/","text":"ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。 ##一、类（Class） 1.基本语法 JavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子12345678910function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;&#125;;var p = new Point(1, 2); 上面的代码用ES6的“类”改写，就是下面这样。12345678910111213//定义类class Point &#123; constructor(x, y) &#123; //constructor 构造方法 this.x = x; this.y = y; &#125; toString() &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; &#125;&#125;var p = new Point(1, 2); 构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都还是定义在类的prototype属性上面。 2.constructor方法 constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 ##二、继承（Extends） Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。12345678910class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + &apos; &apos; + super.toString(); // 调用父类的toString() &#125;&#125; 上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 ##三、原生构造函数继承 原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript的原生构造函数大致有下面这些。以前，这些原生构造函数是无法继承的。 Boolean()Number()String()Array()Date()Function()RegExp()Error()Object() ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。 123456789101112class MyArray extends Array &#123; constructor(...args) &#123; super(...args); &#125;&#125;var arr = new MyArray();arr[0] = 12;arr.length // 1arr.length = 0;arr[0] // undefined 上面代码定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。这意味着，ES6可以自定义原生数据结构（比如Array、String等）的子类，这是ES5无法做到的。 ##四、Class的Generator方法 如果某个方法之前加上星号（*），就表示该方法是一个Generator函数。 12345678910111213141516class Foo &#123; constructor(...args) &#123; this.args = args; &#125; * [Symbol.iterator]() &#123; for (let arg of this.args) &#123; yield arg; &#125; &#125;&#125;for (let x of new Foo(&apos;hello&apos;, &apos;world&apos;)) &#123; console.log(x);&#125;// hello// world 上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个Generator函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for…of循环会自动调用这个遍历器。 ##五、Class的静态方法 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。1234567891011class Foo &#123; static classMethod() &#123; return &apos;hello&apos;; &#125;&#125;Foo.classMethod() // &apos;hello&apos;var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function 上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。 父类的静态方法，可以被子类继承。 12345678910class Foo &#123; static classMethod() &#123; return &apos;hello&apos;; &#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod(); // &apos;hello&apos; 上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。","tags":[{"name":"ES6新特性","slug":"ES6新特性","permalink":"http://qianniuer.github.io/tags/ES6新特性/"}]},{"title":"深入了解JavaScript，优化作用域链（2）","date":"2016-09-21T08:45:46.000Z","path":"2016/09/21/深入了解JavaScript，优化作用域链（2）/","text":"作为一个良好的开发者必需考虑程序的运行性能，作用域链的层级关系是JavaScript性能优化的一个重要部分。因为这关系到变量在内存里的读写速度。 尽量使用局部变量从作用域链的结构可以看出，在执行上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。 全局变量总是存在于执行上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的，并且全局变量将常驻内存直到程序退出，而局部变量会在函数运行完直接销毁。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。 一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。例如：123456789function toggle()&#123; if(document.getElementById('btn').className == 'active')&#123; document.getElementById('btn').className = ''; //do someThing &#125;else&#123; document.getElementById('btn').className = 'active'; //do someThing &#125;&#125; 以上代码中document.getElementById(&#39;btn&#39;).className被引用了三次，查找该变量必须遍历整个作用域链，直到最后在全局对象中才能找到document，然后再去找它的方法和属性，这样严重的影响了程序性能。我们可以改为：12345678910function toggle()&#123; var btnClass = document.getElementById('btn').className; if(btnClass == 'active')&#123; btnClass = ''; //do someThing &#125;else&#123; btnClass = 'active'; //do someThing &#125;&#125; 尽量不要改变作用域链函数每次执行时对应的执行上下文都是独一无二的，所以多次调用同一个函数就会导致创建多个执行上下文，当函数执行完毕，执行上下文会被销毁。每一个执行上下文都和一个作用域链关联。一般情况下，在执行上下文运行的过程中，其作用域链只会被 with 语句和 catch 语句影响。 with语句是对象的快捷应用方式，用来避免书写重复代码。例如：1234567891011121314var o = &#123;href:\"github.com\"&#125;; var href = \"blog.xieliqun.com\"; function buildUrl()&#123; var q = \"?name=tsrot\"; with(o)&#123; var url = href+q; &#125; return url; &#125; var result = buildUrl(); alert(result); //github.com?name=tsrotalert(href); //blog.xieliqun.com 第一个alert使用的o对象里的href，所以弹出github.com?name=tsrot，第二个alert使用的就是全局的href。 当代码运行到with语句时，运行期上下文的作用域链临时被改变了。一个新的可变对象被创建，它包含了参数指定的对象的所有属性。这个对象将被推入作用域链的头部，这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。此时的作用域链为：123456789101112131415161718192021scope -&gt; with.AO -&gt; with.VO -&gt; buildUrl.AO -&gt; Global Objectwith.AO = &#123; url : undefined&#125;with.VO = &#123; href : &quot;github.com&quot;&#125;buildUrl.AO = &#123; q : &quot;?name=tsrot&quot;&#125;Global Object = &#123; o : &#123;href:&quot;github.com&quot;&#125;, href : &quot;blog.xieliqun.com&quot;, buildUrl : &lt;reference to function&gt;, result : undefined&#125; 另外一个会改变作用域链的是try-catch语句中的catch语句。当try代码块中发生错误时，执行过程会跳转到catch语句，然后把异常对象推入一个可变对象并置于作用域的头部。在catch代码块内部，函数的所有局部变量将会被放在第二个作用域链对象中。 闭包问题一个函数只要内部函数未销毁（内部函数存在被调用的可能），这个函数就不会销毁，将一直存在于内存中，只有所有内部函数都销毁了，并所有的业务代码都已执行完，这个函数才会被释放。我们看看最常见的闭包问题：1234567891011function show()&#123; var li = document.getElementsByTagName('li'); var length = li.length; for(var i=0;i&lt;length;i++)&#123; li[i].onclick = function()&#123; alert(i); &#125; &#125;&#125;show(); 当点击li标签时，弹出的一直都是length的大小。这是一个比较经典的错误。为什么会这样呢？ 由于show的内部函数（click事件处理程序时刻有调用可能），所以show的作用域链不能被销毁（只能页面卸载是销毁），i的值一直保持for循环执行完后的length值，此时的click的函数只是进行了声明而未运行，当click触发的时候，函数才开始执行，这个时候i的值已经是length了。所以每次触发onclick的时候才会alert length。我们进行改一下：12345678910111213function show()&#123; var li = document.getElementsByTagName('li'); var length = li.length; for(var i=0;i&lt;length;i++)&#123; (function(n)&#123; li[n].onclick = function()&#123; alert(n); &#125; &#125;)(i) &#125;&#125;show(); 为什么这样就行了呢，这时候onclick引用的变量变成了n，而由于立即执行函数的原因，每个onclick函数在作用域链中分别保持着对应的n（0~length-1），这时候就可以了。 闭包会使子函数保持其作用域链的所有变量及函数与内存中，内存消耗很大，在使用的时候尽量销毁父函数不再使用的变量。你经常访问一些范围之外的标识符，每次访问都将导致一些性能损失。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://qianniuer.github.io/tags/JavaScript/"}]},{"title":"coding.net IDE node环境的安装","date":"2016-09-11T08:45:46.000Z","path":"2016/09/11/折腾：coding.net IDE node环境的安装/","text":"作为一个码农，我们经常会有这样一个痛点：项目出现一个紧急bug，但自己又不在公司，怎办呢？虽然项目可能在git或者svn上，但clone下来安装测试环境也是个麻烦的是啊。于是，我们想到了在线IDE。作为一个前端开发者nodeJS环境是非常重要的，今天花了一个多小时折腾了下coding.net。 IDE介绍以前我一直在用nitrous.io的在线IDE，它是一个国外的在线IDE，访问有点慢，一旦网络不好就掉线，挺好的地方就是，它每个月有50个小时的免费使用。coding.net相当于是一个国内版的github，也是一个远程的git仓库，它有个在线IDE还挺好用的。有终端命令面板、支持vim和 Emacs的编辑器、在线运行环境、支持git（哎，帮别人做广告了，不知道coding能不能发我点稿费）。 下面进入主题。 安装nvmnvm是nodejs版本管理工具。可以在多个nodejs版本中进行切换，降低了升级nodejs时的成本。 下载nvm，直接在终端面板把它clone过来就行了。为了不影响项目目录，我们把它clone在项目根目录的同级目录。12-&gt; ~ cd ..-&gt; ~ git clone https://github.com/creationix/nvm.git 接下来，进入nvm目录1-&gt; ~ cd nvm 安装nvm1-&gt; ~ ./install.sh 安装完后，让系统自动执行它1-&gt; ~ source ./nvm.sh 现在就可以使用nvm命令了，查看一下help1-&gt; ~ nvm -help 安装nodeJS查看可以安装的nodejs版本，这里将会输出一大堆可供安装的nodejs版本1-&gt; ~ nvm ls-remote 选择一个进行安装，我安装的是v4.5.01-&gt; ~ nvm install v4.5.0 当然你可以安装多个版本，例如我还要安装最新版本，测试一下它的新特性1-&gt; ~ nvm install v6.4.0 当你想切换回原先稳定版本时，你可以1-&gt; ~ nvm use v4.5.0 安装完node，你就可以使用node和npm了。你可以安装一些自动化工具啊，一些插件啊什么的。 一些问题1、这些在线IDE虽然挺方便的，但毕竟没有本地的好，还有一些安全和网络限制的问题，另外到后面可能还要收费。 2、nvm问题，因为coding没有给用户root权限，所以你每次要运行node前都必须运行一下nvm。 123-&gt; ~ cd ..-&gt; ~ cd nvm-&gt; ~ source ./nvm.sh END","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://qianniuer.github.io/tags/JavaScript/"}]},{"title":"模仿知乎界面的一个简单React demo","date":"2016-08-09T08:37:46.000Z","path":"2016/08/09/模仿知乎界面的一个简单React demo/","text":"这是一个模仿知乎界面的简单React demo。这个React demo能让你从零开始学习React，并逐渐掌握React。它包括了一个项目从零到项目完成的整个过程。 项目地址：https://github.com/tsrot/react-zhihu项目预览：http://blog.xieliqun.com/react-zhihu/ 项目运行12345678$ git clone https://github.com/tsrot/react-zhihu.git$ cd react-zhihu$ npm install$ bower install$ gulp server //用浏览器打开 localhost:5000 搭建开发环境初始化npm bower123npm init //一直enter，默认就好bower init //同上 安装必要的开发工具包 gulp ：基于流的自动化构建工具 gulp-browserify ：前端模块及依赖管理 gulp-concat ：文件合并插件 gulp-react ：JSX语法转化工具 gulp-connect ：构建本地开发Web服务器 lodash ：一个具有一致接口、模块化、高性能等特性的 JavaScript 工具库 reactify ：React 编译器 1npm install gulp gulp-browserify gulp-concat gulp-react gulp-connect lodash reactify --save-dev 安装生产环境依赖包 react ：主要框架 react-dom ：React的DOM操作类 bootstrap ：bootstrap样式 123npm install --save react react-dombower install --save bootstrap 写入gulp配置文件gulpfile.js你可以在npm的网站上找到相应插件的gulp配置写法。我配置的gulpfile.js 开发 切分相应的模块 分清UI组件和容器组件 学会如何在组件之间通信 注意写作规范和开发细节 部署生产请切换分支到 product 分支 修改gulpfile文件1234567891011121314151617181920212223242526//添加copy任务gulp.task('copy',function()&#123; gulp.src('./app/css/*') .pipe(gulp.dest('./dist/css')); gulp.src('./bower_components/**/*') .pipe(gulp.dest('./dist/libs')); gulp.src('./*.html') .pipe(gulp.dest('./dist'));&#125;);//生产服务器gulp.task('connect-pro',function()&#123; connect.server(&#123; root:'./dist', port:port, livereload:true, &#125;)&#125;);//添加build任务gulp.task('build',['browserify','copy']);//添加启动生产服务器任务gulp.task('server-pro',['build','connect-pro','watch']); 修改index.html引用目录1234&lt;link rel=&quot;stylesheet&quot; href=&quot;./libs/bootstrap/dist/css/bootstrap.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;./css/index.css&quot;&gt;&lt;script src=&quot;./js/main.js&quot;&gt;&lt;/script&gt; 使用gulp-gh-pages部署到github pages下载gulp-gh-pages插件1npm install --save-dev gulp-gh-pages 在gulpfile文件中添加配置gulp-gh-pages代码123456var ghPages = require('gulp-gh-pages');gulp.task('deploy', function() &#123; return gulp.src('./dist/**/*') .pipe(ghPages());&#125;); 后续将在分支中更新使用下列技术的版本 webpack webpack + redux webkack + redux + react-router","tags":[{"name":"Arguments","slug":"Arguments","permalink":"http://qianniuer.github.io/tags/Arguments/"}]},{"title":"深入了解JavaScript，从作用域链开始（1）","date":"2016-06-16T08:37:46.000Z","path":"2016/06/16/深入了解JavaScript，从作用域链开始（1）/","text":"作用域是每种计算机语言最重要的基础之一，当然它也是JavaScript最重要的概念之一。要想真正的深入了解JavaScript，了解JavaScript的作用域链非常必要。现在让我们深入了解JavaScript作用域和作用域链的工作原理 深入了解JavaScript，从作用域链开始（1）JavaScript的作用域是什么作用域，在维基百科上解释是：在电脑程序设计中，作用域（scope，或译作有效范围）是名字（name）与实体（entity）的绑定（binding）保持有效的那部分计算机程序。简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，变量的作用域有全局作用域和局部作用域两种，局部作用域又称为函数作用域。 全局作用域在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域： （1）程序最外层定义的函数或者变量123456789101112var a = \"tsrot\";function hello()&#123; alert(a);&#125;function sayHello()&#123; hello();&#125;alert(a); //能访问到tsrothello(); //能访问到tsrotsayHello(); //能访问到hello函数，然后也能访问到tsrot （2）所有末定义直接赋值的变量（不推荐）1234567function hello()&#123; a = \"tsrot\"; var b = \"hello tsrot\";&#125;alert(a); //能访问到tsrotalert(b); //error 不能访问 （3）所有window对象的属性和方法一般情况下，window对象的内置属性都拥有全局作用域，例如window.name、window.location、window.top等等。 局部作用域（函数作用域）局部作用域在函数内创建，在函数内可访问，函数外不可访问。1234567function hello()&#123; var a = \"tsrot\"; alert(a);&#125;hello(); //函数内可访问到tsrotalert(a); //error not defined 作用域链是什么了解作用域链之前我们要知道一下几个概念： 变量和函数的声明 函数的生命周期 Activetion Object（AO）、Variable Object（VO） 变量和函数的声明在JavaScript引擎解析JavaScript代码的时候，首先，JavaScript引擎会把变量和函数的声明提前进行预解析，然后再去执行其他代码。 变量声明：变量的声明只有一种方式，那就是用var关键字声明，直接赋值不是一种声明方式。这仅仅是在全局对象上创建了新的属性（而不是变量）。它们有一下区别：（1）因为它只是一种赋值，所以不会声明提前1234alert(a); // undefinedalert(b); // error \"b\" is not definedb = 10;var a = 20; （2）直接赋值形式是在执行阶段创建123456alert(a); // undefined, 这个大家都知道b = 10;alert(b); // 10, 代码执行阶段创建 var a = 20;alert(a); // 20, 代码执行阶段修改 （3）变量不能删除（delete），属性可以删除12345678910111213a = 10;alert(window.a); // 10 alert(delete a); // true alert(window.a); // undefined var b = 20;alert(window.b); // 20 alert(delete b); // false alert(window.b); // 仍然为 20，因为变量是不能够删除的。 但是，这里有一个意外情况，就是在“eval”的上下文中，变量是可以删除的：123456eval('var a = 10;');alert(window.a); // 10 alert(delete a); // true alert(window.a); // undefined 有些debug工具也是可以删除的，因为它们使用了 eval()方法来执行代码的。 函数声明：函数的声明有三种方式（1）function name( ){ }直接创建方式12345function add(a,b)&#123; return a+b;&#125;add(5,4); （2）new Funtion构建函数创建123var add=new Function(\"a\", \"b\", \"return a+b;\");add(4,5); （3）给变量赋值匿名函数方法创建12345var add = function(a,b)&#123; return a+b;&#125;add(4,5); 后面两种方法，在声明前访问时，返回的都是一个undefined的变量。当然，在声明后访问它们都是一个function的函数。 注意：如果变量名和函数名声明时相同，函数优先声明。12345678910alert(x); // functionvar x = 10;alert(x); // 10 x = 20;function x() &#123;&#125;; alert(x); // 20 函数的生命周期函数的的生命周期分为创建和执行两个阶段。 在函数创建阶段，JS解析引擎进行预解析，会将函数声明提前，同时将该函数放到全局作用域中或当前函数的上一级函数的局部作用域中。 在函数执行阶段，JS引擎会将当前函数的局部变量和内部函数进行声明提前，然后再执行业务代码，当函数执行完退出时，释放该函数的执行上下文，并注销该函数的局部变量。 什么是AO、VO英文解释：AO：Activetion Object（活动对象）VO：Variable Object（变量对象） VO对应的是函数创建阶段，JS解析引擎进行预解析时，所有的变量和函数的声明，统称为Variable Object。该变量与执行上下文相关，知道自己的数据存储在哪里，并且知道如何访问。VO是一个与执行上下文相关的特殊对象，它存储着在上下文中声明的以下内容： 变量 (var, 变量声明); 函数声明 (FunctionDeclaration, 缩写为FD); 函数的形参 举个例子：12345678function add(a,b)&#123; var sum = a + b; function say()&#123; alert(sum); &#125; return sum;&#125;// sum,say,a,b 组合的对象就是VO，不过该对象的值基本上都是undefined AO对应的是函数执行阶段，当函数被调用执行时，会建立一个执行上下文，该执行上下文包含了函数所需的所有变量，该变量共同组成了一个新的对象就是Activetion Object。该对象包含了： 函数的所有局部变量 函数的所有命名参数 函数的参数集合 函数的this指向 举个例子：123456789101112131415161718function add(a,b)&#123; var sum = a + b; function say()&#123; alert(sum); &#125; return sum;&#125;add(4,5);// 我用JS对象来表示AO// AO = &#123;// this : window,// arguments : [4,5],// a : 4,// b : 5,// say : &lt;reference to function&gt;,// sum : undefined// &#125; JavaScript作用域链现在我们回到主题，作用域链。 当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）来保证对执行环境有权访问的变量和函数的有序访问。作用域第一个对象始终是当前执行代码所在环境的变量对象（VO）。1234function add(a,b)&#123; var sum = a + b; return sum;&#125; 假设函数是在全局作用域中创建的，在函数a创建的时候，它的作用域链填入全局对象,全局对象中有所有全局变量，此时的全局变量就是VO。此时的作用域链就是： 12345678此时作用域链（Scope Chain）只有一级,就为Global Object scope(add) -&gt; Global Object(VO) VO = &#123; this : window, add : &lt;reference to function&gt; &#125; 如果是函数执行阶段，那么将其activation object（AO）作为作用域链第一个对象，第二个对象是上级函数的执行上下文AO，下一个对象依次类推。1add(4,5); 例如，调用add后的作用域链是： 12345678910111213141516此时作用域链（Scope Chain）有两级，第一级为AO，然后Global Object（VO） scope(add) -&gt; AO -&gt; VO AO = &#123; this : window, arguments : [4,5], a : 4, b : 5, sum : undefined &#125; VO = &#123; this : window, add : &lt;reference to function&gt; &#125; 在函数运行过程中标识符的解析是沿着作用域链一级一级搜索的过程，从第一个对象开始，逐级向后回溯，直到找到同名标识符为止，找到后不再继续遍历，找不到就报错。 看过上面的内容后，可能还有人不懂，我再通熟易懂的解释一遍，先举个例子：123456789101112131415var x = 10; function foo() &#123; var y = 20; function bar() &#123; var z = 30; console.log(x + y + z); &#125;; bar()&#125;; foo(); 上面代码的输出结果为”60″，函数bar可以直接访问”z”，然后通过作用域链访问上层的”x”和”y”。此时的作用域链为：1234567891011121314151617181920此时作用域链（Scope Chain）有三级，第一级为bar AO，第二级为foo AO,然后Global Object（VO） scope -&gt; bar.AO -&gt; foo.AO -&gt; Global Object bar.AO = &#123; z : 30, __parent__ : foo.AO &#125; foo.AO = &#123; y : 20, bar : &lt;reference to function&gt;, __parent__ : &lt;Global Object&gt; &#125; Global Object = &#123; x : 10, foo : &lt;reference to function&gt;, __parent__ : null &#125; 未完待续。。。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://qianniuer.github.io/tags/JavaScript/"}]},{"title":"JavaScript中this指向","date":"2016-05-17T08:37:46.000Z","path":"2016/05/17/JavaScript中this指向/","text":"对于JavaScript初学者来说，this指针的指向问题一直是很混乱的问题。在不同的场景下，this会化身不同的对象。有一种观点认为，只有正确掌握了JavaScript 中的 this 关键字，才算是迈入了 JavaScript这门语言的门槛。在主流的面向对象的语言中（例如Java,C#等)，this 含义是明确且具体的，即指向当前对象。一般在编译期绑定。而JavaScript 中this 在运行期进行绑定的，这是JavaScript 中this 关键字具备多重含义的本质原因。 随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。 1、 指向window的隐式指向12345function sayHello()&#123; this.name = \"tsrot\"; console.log(\"hello \" + this.name);&#125;sayHello() //hello tsrot 此时的变量name相当于window.name，因为调用sayHello函数的对象为window，相当于window.sayHello()。和下面两种情况是一样的：12345var name = \"tsrot\";function sayHello()&#123; console.log(\"hello \" + this.name);&#125;sayHello(); //hello tsrot 下面的name相当于在window下赋值了两次，谁后面执行就取谁。如果把var name = “xieliqun”放到sayHello（）后面，此时输出的就是 hello xieliqun。123456var name = \"xieliqun\";function sayHello()&#123; this.name = \"tsrot\";&#125;sayHello(); console.log(\"hello \" + this.name); //hello tsrot 注：当函数在DOM上调用时，未传入this，此时，this也指向window。当传入this时，this指向当前DOM input，例如下面情况：123456&lt;input type=&quot;button&quot; value=&quot;click me&quot; onclick=&quot;sayHello()&quot;&gt;&lt;script&gt; function sayHello()&#123; console.log(&quot;hello &quot; + this.tagName); //hello undefined &#125;&lt;/script&gt; 123456&lt;input type=&quot;button&quot; value=&quot;click me&quot; onclick=&quot;sayHello(this.tagName)&quot;&gt;&lt;script&gt; function sayHello(tagName)&#123; console.log(&quot;hello &quot; + tagName); //hello INPUT &#125;&lt;/script&gt; 2、 指向当前对象的显式调用（1）、作为对象方法的调用函数还可以作为某个对象的方法调用，这时this就指这个上级对象。1234567function sayHello()&#123; console.log(\"hello \" + this.name);&#125;var o = &#123;&#125;;o.name = \"tsrot\";o.hello = sayHello;o.hello(); //hello tsrot （2）、作为构造函数调用所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。12345function sayHello()&#123; this.name = \"tsrot\";&#125;var o = new sayHello();console.log(\"hello \" + o.name); //hello tsrot 3、 指向当前对象的隐式调用（1） call、apply调用call（）、apply()都是函数对象的一个方法，它们的作用是改变函数的调用对象，它们的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。1234567function sayHello()&#123; console.log(\"hello \" + this.name);&#125;var o = &#123;&#125;;o.name = \"tsrot\";o.hello = sayHello;o.hello.apply(); //hello apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。如果把最后一行代码修改为12345// o.hello.apply(); //helloo.hello.apply(o); //hello tsroto.hello.apply(this); //hello tsroto.hello.call(o); //hello tsroto.hello.call(this); //hello tsrot 此时this就指向对象o了。 （2） 原生Function方法bind（）调用很多人不知道原生js也有bind（）方法，一直以为bind（）的方法只有jQuery有，我也是最近看别人博客知道的。其实原生的bind和jQuery的bind是不同的，原生的bind相当于apply和call。12345678var person = &#123; name:\"tsrot\", sayHello:function()&#123; console.log(\"你好，我是\"+this.name); &#125;&#125;var boundFunc = person.sayHello.bind(person,person.sayHello);setTimeout(boundFunc,5000); //5秒后输出 你好，我是tsrot ,[setTimeout 涉及一些执行栈的问题](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout)，或者简单的理解,在浏览器中setTimeout是window的属性。 下图代码中person.sayHello,相当于在window.person.sayHello，所以this指向window。12345678var person = &#123; name:\"tsrot\", sayHello:function()&#123; console.log(\"你好，我是\"+this.name); &#125;&#125;//var boundFunc = person.sayHello.bind(person,person.sayHello);setTimeout(person.sayHello,5000); //5秒后输出 你好，我是 用apply和call调用时，函数将立即执行12345678var person = &#123; name:\"tsrot\", sayHello:function()&#123; console.log(\"你好，我是\"+this.name); &#125;&#125;var boundFunc = person.sayHello.apply(person,person.sayHello);setTimeout(boundFunc,5000); //立即输出 你好，我是tsrot 4、 当this在构造函数有return时如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。123456function fn()&#123; this.name = \"tsrot\"; return &#123;&#125;;&#125;var o = new fn();console.log(o.name); //undefined 123456function fn()&#123; this.name = \"tsrot\"; return function()&#123;&#125;;&#125;var o = new fn();console.log(o.name); //undefined 当return null和undefined时123456function fn()&#123; this.name = \"tsrot\"; return null;&#125;var o = new fn();console.log(o.name); //tsrot 123456function fn()&#123; this.name = \"tsrot\"; return undefined;&#125;var o = new fn();console.log(o.name); //tsrot","tags":[{"name":"原理","slug":"原理","permalink":"http://qianniuer.github.io/tags/原理/"}]},{"title":"AJAX工作原理","date":"2016-05-03T01:03:46.000Z","path":"2016/05/03/Ajax工作原理/","text":"AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 一、ajax所包含的技术 大家都知道ajax并非一种新的技术，而是几种原有技术的结合体。它由下列技术组合而成。 使用CSS和XHTML来表示。 使用DOM模型来交互和动态显示。 使用XMLHttpRequest来和服务器进行异步通信。 使用javascript来绑定和调用。 在上面几中技术中，除了XmlHttpRequest对象以外，其它所有的技术都是基于web标准并且已经得到了广泛使用的，XMLHttpRequest虽然目前还没有被W3C所采纳，但是它已经是一个事实的标准，因为目前几乎所有的主流浏览器都支持它。 二、怎样创建ajaxAjax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。原生创建ajax可分为以下四步。 1、创建XMLHttpRequest对象所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。创建 XMLHttpRequest 对象的语法：1var xhr = new XMLHttpRequest(); 老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象：1var xhr = new ActiveXObject(\"Microsoft.XMLHTTP\"); 为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ：123456var xhr;if(XMLHttpRequest)&#123; xhr = new XMLHttpRequest();&#125;else&#123; xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");&#125; 2、准备请求初始化该XMLHttpRequest对象，接受三个参数：1xhr.open(method,url,async); 第一个参数表示请求类型的字符串，其值可以是GET或者POST。GET请求：1xhr.open(\"GET\",demo.php?name=tsrot&amp;age=24,true); POST请求：1xhr.open(\"POST\",demo.php,true); 第二个参数是要作为请求发送目标的URL。第三个参数是true或false，表示请求是以异步还是同步的模式发出。（默认为true，一般不建议为false） false：同步模式发出的请求会暂停所有javascript代码的执行，知道服务器获得响应为止，如果浏览器在连接网络时或者在下载文件时出了故障，页面就会一直挂起。 true：异步模式发出的请求，请求对象收发数据的同时，浏览器可以继续加载页面，执行其他javascript代码 3、发送请求1xhr.send(); 一般情况下，使用Ajax提交的参数多是些简单的字符串，可以直接使用GET方法将要提交的参数写到open方法的url参数中，此时send方法的参数为null或为空。 GET请求： 12xhr.open(\"GET\",demo.php?name=tsrot&amp;age=24,true);xhr.send(null); POST请求：如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定您希望发送的数据： 123xhr.open(\"POST\",demo.php,true);xhr.setRequestHeder(\"Content-Type\",\"application/x-www-form-urlencoded;charset=UTF-8\");xhr.send(\"name=\"+userName+\"&amp;age=\"+userAge); 4、处理响应12345xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; console.log(xhr.responseText); &#125;&#125; onreadystatechange 事件：当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当 readyState 改变时，就会触发 onreadystatechange 事件。 readyState属性：0：已经创建对象，但还没有调用open()方法。1：已经调用open()方法，但还没有发送请求。2：请求已经发送，标题和状态已经收到，并可用。3：接收到来自服务器的响应。4：接收完请求数据，表示已经完成请求。 status属性：200:”OK”404: 未找到页面 responseText：获得字符串形式的响应数据responseXML：获得 XML 形式的响应数据返回值一般为json字符串，可以用JSON.parse(xhr.responseText)转化为JSON对象。 5、完整例子demo.html123456789101112131415var xhr;if(XMLHttpRequest)&#123; xhr = new XMLHttpRequest();&#125;else&#123; xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");&#125;;xhr.open(\"GET\",\"./data.json\",true);xhr.send();xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; console.log(JSON.parse(xhr.responseText).name); &#125;&#125; data.json1234&#123; \"name\":\"tsrot\", \"age\":24&#125; 三、ajax应用场景 场景 1. 数据验证 场景 2. 按需取数据 场景 3. 自动更新页面 四、ajax优缺点优点：1、页面无刷新，用户体验好。2、异步通信，更加快的响应能力。3、减少冗余请求，减轻了服务器负担4、基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。 缺点：1、ajax干掉了back按钮，即对浏览器后退机制的破坏。2、存在一定的安全问题。3、对搜索引擎的支持比较弱。4、破坏了程序的异常机制。5、无法用URL直接访问。","tags":[{"name":"原理","slug":"原理","permalink":"http://qianniuer.github.io/tags/原理/"}]},{"title":"世界上最美的20条街道","date":"2016-04-23T04:47:11.000Z","path":"2016/04/23/世界上最美的20条街道/","text":"boredpanda网站上投票选出的世界上最美的20条街道。 希腊莱斯沃斯岛 德国波恩 瑞典斯德哥尔摩 美国华盛顿 西班牙瓦伦西亚 南非比勒陀利亚 中国台湾 意大利斯佩罗 澳大利亚格拉夫顿 希腊纳夫普里翁 巴西阿雷格里港 西班牙赫雷斯 意大利波西塔诺 澳大利亚布里斯班 乌克兰爱的隧道 日本紫藤隧道 美国丹佛 津巴布韦哈拉雷 美国萨凡纳 波兰卡卢森","tags":[{"name":"街道","slug":"街道","permalink":"http://qianniuer.github.io/tags/街道/"},{"name":"最美","slug":"最美","permalink":"http://qianniuer.github.io/tags/最美/"}]},{"title":"只需50个词","date":"2016-04-21T02:28:06.000Z","path":"2016/04/21/只需50个词/","text":"作者：连岳 阅读能不能让人过上幸福的日子？也许不能，可是，不能阅读肯定过不上幸福的日子。阅读的门槛不高，大可不必放弃这种能力。 有一万个词汇，可以精读《莎士比亚全集》； 有六千个词汇，可以精读《圣经》； 有四千个词汇，可以精读《堂·吉诃德》；有一千个词汇，可以精读《金刚经》； 只有五十个词汇，可以精读苏斯博士的《绿蛋与火腿》。 1960年，苏斯博士和朋友打赌，可以用五十个词汇写一本好书，他做到了，并且赢了五十美元。这本书讲述一只怪物克服恐惧，吃下绿蛋与火腿的故事。有人说它是童话，有人将之视为人生指南，也有人将之归类为诗歌。五十个词汇，构筑知识迷宫，迷住所有误闯其中的人。 只要认识五十个字，就可以趋近于无限的可能性，这个便宜，一定要捡。","tags":[{"name":"读书","slug":"读书","permalink":"http://qianniuer.github.io/tags/读书/"},{"name":"读者","slug":"读者","permalink":"http://qianniuer.github.io/tags/读者/"}]},{"title":"JavaScript闭包（closure）","date":"2016-04-16T08:37:46.000Z","path":"2016/04/16/JavaScript闭包(closure)/","text":"JavaScript变量分为全局变量和局部变量。Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量，而在函数外部自然无法读取函数内的局部变量。当你需要在函数外调用函数内的局部变量时，此时就要用到一些方法。这个过程就是闭包。 ###一、JavaScript为什么会有闭包这种东西JavaScript没有像其它后端语言一样可以直接定义一个变量可供其它外部函数调用的关键字或者方法。于是就产生了闭包这种东西。举个例子：123456//内部函数可以访问外部变量var name = \"tsrot\";function f1()&#123; console.log(name);&#125;f1(); //tsrot 12345//函数外部无法访问函数内部的局部变量function f2()&#123; var name = \"tsrot\"; //注意:不用var定义的变量，将会默认为全局变量&#125;console.log(name); //error undefined 如果是java，一个类的私有属性，可以通过公共的方法来获取，比如：123456class Person&#123; private String name; public String getName()&#123; return name; &#125; &#125; 二、闭包的概念闭包，官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。闭包的特点： 作为一个函数变量的一个引用，当函数返回时，其处于激活状态。 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。 我的理解就是：让函数外部能调用函数内部变量的一个过程就是闭包。举个例子：123456789function f1()&#123; var name1 = \"tsrot\"; function f2()&#123; return name1; &#125; return f2;&#125;var fun = f1(); //此时就访问到了name1的值console.log(fun()) //tsrot ###三、闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。举个例子：1234567891011function f1()&#123; var n = 0; function f2()&#123; n++; console.log(n); &#125; return f2; //注意此时应该写f2而不是f2()&#125;var fun = f1();fun(); //1fun(); //2 此时n就保存在了内存中 四、闭包的写法1、原型调用写法12345678910//在函数内部添加属性，然后在外部调用function Circle(r) &#123; this.r = r; &#125; Circle.PI = 3.14159; Circle.prototype.area = function() &#123; return Circle.PI * this.r * this.r; &#125;var c = new Circle(1.0); console.log(c.area()); 2、函数赋值调用写法12345678910var Circle = function() &#123; var obj = new Object(); obj.PI = 3.14159; obj.area = function(r) &#123; return this.PI * r * r; &#125; return obj; &#125;; var c = new Circle(); console.log(c.area(1.0)); 3、对象赋值调用写法（常用写法）123456var Circle = new Object(); Circle.PI = 3.14159; Circle.area = function(r) &#123; return this.PI * r * r; &#125;;consol.log(Circle.area(1.0)); 4、声明对象调用写法（比较好的一种写法）1234567var Circle=&#123; PI : 3.14159, area : function(r)&#123; return this.PI * r * r; &#125; &#125;; console.log(Circle.area(1.0)) 5、Function对象调用写法1234//比较少见的一种写法var Circle = new Function(\"this.PI = 3.14159;this.area = function( r ) &#123;return r*r*this.PI;&#125;\"); var c = new Circle();console.log(c.area(1.0)); 6、匿名函数调用写法（常用写法）12345(function(r)&#123; var PI = 3.14159; var area = PI * r * r; console.log(area);&#125;)(1.0) 7、函数返回值写法（常用写法）12345678function Circle(r)&#123; var PI = 3.14159; function area()&#123; return PI * r * r; &#125; return area();&#125;console.log(Circle(1.0)); 五、思考思考1：修改下面函数使之输出数组内元素？123456789function test()&#123; var arr = [1,2,3,4,5]; for(var i=0;i&lt;arr.length;i++)&#123; setTimeout(function()&#123; console.log(arr[i]); &#125;,1000); &#125;&#125;test(); 思考2：修改下面代码使之输出它想表达的结果 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id=&quot;list&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt;&lt;script&gt; var list = document.getElementById(&apos;list&apos;); var li = list.getElementsByTagName(&apos;li&apos;); for(var i=0;i&lt;li.length;i++)&#123; li[i].onclick = function()&#123; alert(li[i].innerHTML); //这里报错 &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 答案11234567891011function test()&#123; var arr = [1,2,3,4,5] for(var i=0;i&lt;5;i++)&#123; (function(i)&#123; setTimeout(function()&#123; console.log(arr[i]); &#125;,1000); &#125;)(i) &#125;&#125;test(); 答案2 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id=&quot;list&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt;&lt;script&gt; var list = document.getElementById(&apos;list&apos;); var li = list.getElementsByTagName(&apos;li&apos;); for(var i=0;i&lt;li.length;i++)&#123; (function(i)&#123; li[i].onclick = function()&#123; alert(li[i].innerHTML); &#125; &#125;)(i) &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"闭包","slug":"闭包","permalink":"http://qianniuer.github.io/tags/闭包/"}]},{"title":"各阶段前端工程师都应该具备什么能力（JS篇）","date":"2016-04-16T08:37:46.000Z","path":"2016/04/16/各阶段前端工程师都应该具备什么能力（JS篇）/","text":"作为一名程序猿、攻城狮，要清楚自己的实力，自己所处的阶段，这样才能更好的扬长补短。常问自己几个问题：我最擅长什么，我比别人有哪些优势？我的短板在哪些方面？我在整个行业所处什么阶段，在这个阶段我该如何提升自己？对于前端工程师等级的划分，每个人都可能有自己的理解，正所谓，一千个读者就有一千个哈姆雷特。下面是我对前端工程师划分的一些拙见。 一、入门菜鸟这个阶段一般具备以下几点： 基础的JavaScript编程能力 基本能看懂别人写的代码 有一定的代码调试能力 举些例子： 1、怎样对字符串进行截取操作，你会想到哪些方法？substr() ,sibString(), split(), slice() … 2、给你一段代码，你能知道这段代码实现了什么功能，别人为什么要这么写？123456var url = window.location.href;if(url === 'http://www.xieliqun.com')&#123; window.location.href = 'https://github.com/tsrot';&#125;else&#123; window.location.href = '/404';&#125; 3、给你一段简单的错误代码，你能知道错在哪里，怎样去改正它？123456var foo = 'hello world!';var arr = [];for(var i=0;i&lt;foo.length;i++)&#123; var fooArr = arr.push(foo[i]); console.log(fooArr);&#125; 二、初级工程师初级工程师应该能够： 解决一些例如特效方面的问题 能使用一些框架，例如jQuery、bootstrap等 能使用ajax进行简单的前后通信 能DOM编程解决一些问题 能熟练使用浏览器的调试工具 了解一些HTML 5 API 了解ES5 规范 举些例子： 1、怎样实现一个焦点图的效果？在这个阶段只要能正确解决问题就好了。你可以自己去写代码实现，无论是原生，还是使用jQuery，你也可以百度去网上找一些焦点图的插件，或别人总结的方法。只要能够无错地完成需求，不考虑代码冗余之类的带来的性能问题。 2、使用jQuery完成一个简单的动画？假如完成一个可控制的球在水平面跳动的效果。你应该想怎样触发球，是hover还是click，球怎样跳动起来，是用css样式来控制，还是用jQuery的animate函数来执行动画。 3、怎样使用ajax完成用户名验证？你要完整的说出它的思路，首先用户输入完用户名，失去焦点（blur）后，然后通过ajax POST或者GET把用户名提交到后端，此时后端会给你一个接口，你把用户名传到这个接口，后端应该会返回一个true or false给你，根据返回的结果，作出相应的用户提示。 4、如何动态的插入、删除、替换一个DOM元素？原生方法：appendChild()、removeChild()、innerHTML、replaceChild() …jQuery方法：append()、empty()、html()、remove()、replaceAll() … 5、H5 新增了哪些API？localStorage 、sessionStorage、ApplicationCache、postMessage、file、canvas … 6、ES5 比 ES3 有哪些新特性？语法上更严格了，定义变量必需使用var，否则报错。对Object的控制更精确了，Object.defineProperty可控制对象的读写枚举等，更加丰富了一个对象。对数组Array和字符串 String也增加了一些方法，等等。 三 、中级工程师中级工程师应该具备： 深入理解this、闭包、事件模型、原型和原型链、作用域链、继承等概念 尽量使用ES5编写代码，了解ES6 熟悉前后端通信方式 熟悉一些前端技术框架设计思想、优劣势等 熟悉模块化、面向对象、MVC等编程思想 能自己独立封装一些组件 编码时尽量考虑性能优化 了解常见的http状态码 了解前端工程化思想 了解一些最新的技术框架等 了解函数式编程思想 举些例子：自找答案 setTimeout中function里面的this指向什么？ 写一个最常见的闭包问题？ 如何深度克隆一个对象？ 前后端有哪些通信方式？ jQuery里的ready函数是怎样实现的，和原生的load有什么不同？ 谈谈commonJS和AMD的区别？ JavaScript是如何实现面向对象的？ 谈一谈JavaScript的性能优化问题？ bower、grunt、gulp、yeoman、webpack的了解？ JavaScript的异步编程？ 四、高级工程师高级前端工程师应该具备： 使用前端工程化思维开发 JavaScript对DOM操作的各种方式与性能开销 熟悉RESTful架构、跨域等技术 能对代码进行良好的性能优化 了解常用框架功能原理的代码实现 熟悉前端开发的一些安全问题 熟悉常见跨浏览器问题 了解必要的计算机网络协议 熟悉JavaScript的前后端开发 熟悉各种开发设计模式 了解前端的一些测试方法 举些例子：自找答案 如何解决回调层级过深的问题？ CORS跨域的原理？ 谈谈各种本地存储方案的优势与弊端？ JS延迟加载的方式有哪些？ 哪些操作会造成内存泄漏？ 写一个通用的事件侦听器函数？ 介绍一下XSS和CSRF的原理和防范？ 如何实现一个简易个模块管理库？ 介绍for in的技术细节与性能问题？ jQuery操作DOM细节？ 谈谈JS的满加载和断点续调问题？ 如何实现JS的依赖注入？","tags":[{"name":"摘要","slug":"摘要","permalink":"http://qianniuer.github.io/tags/摘要/"}]},{"title":"事件绑定、事件监听、事件委托","date":"2016-04-16T08:37:46.000Z","path":"2016/04/16/事件绑定、事件监听、事件委托/","text":"在JavaScript的学习中，我们经常会遇到JavaScript的事件机制，例如，事件绑定、事件监听、事件委托（事件代理）等。这些名词是什么意思呢，有什么作用呢？ 事件绑定要想让 JavaScript 对用户的操作作出响应，首先要对 DOM 元素绑定事件处理函数。所谓事件处理函数，就是处理用户操作的函数，不同的操作对应不同的名称。 在JavaScript中，有三种常用的绑定事件的方法： 在DOM元素中直接绑定； 在JavaScript代码中绑定； 绑定事件监听函数。 在DOM中直接绑定事件我们可以在DOM元素上绑定onclick、onmouseover、onmouseout、onmousedown、onmouseup、ondblclick、onkeydown、onkeypress、onkeyup等。好多不一一列出了。如果想知道更多事件类型请查看，DOM事件。 1234567&lt;input type=\"button\" value=\"click me\" onclick=\"hello()\"&gt;&lt;script&gt;function hello()&#123; alert(\"hello world!\");&#125;&lt;/script&gt; 在JavaScript代码中绑定事件在JavaScript代码中（即script标签内）绑定事件可以使JavaScript代码与HTML标签分离，文档结构清晰，便于管理和开发。 1234567&lt;input type=\"button\" value=\"click me\" id=\"btn\"&gt;&lt;script&gt;document.getElementById(\"btn\").onclick = function()&#123; alert(\"hello world!\");&#125;&lt;/script&gt; 使用事件监听绑定事件绑定事件的另一种方法是用 addEventListener() 或 attachEvent() 来绑定事件监听函数。下面详细介绍，事件监听。 事件监听关于事件监听，W3C规范中定义了3个事件阶段，依次是捕获阶段、目标阶段、冒泡阶段。 起初Netscape制定了JavaScript的一套事件驱动机制（即事件捕获）。随即IE也推出了自己的一套事件驱动机制（即事件冒泡）。最后W3C规范了两种事件机制，分为捕获阶段、目标阶段、冒泡阶段。IE8以前IE一直坚持自己的事件机制（前端人员一直头痛的兼容性问题），IE9以后IE也支持了W3C规范。 W3C规范语法：1element.addEventListener(event, function, useCapture) event : （必需）事件名，支持所有DOM事件。function：（必需）指定要事件触发时执行的函数。useCapture：（可选）指定事件是否在捕获或冒泡阶段执行。true，捕获。false，冒泡。默认false。 注：IE8以下不支持。12345678&lt;input type=\"button\" value=\"click me\" id=\"btn1\"&gt;&lt;script&gt;document.getElementById(\"btn1\").addEventListener(\"click\",hello);function hello()&#123; alert(\"hello world!\");&#125;&lt;/script&gt; IE标准语法：1element.attachEvent(event, function) event：（必需）事件类型。需加“on“，例如：onclick。function：（必需）指定要事件触发时执行的函数。 12345678&lt;input type=\"button\" value=\"click me\" id=\"btn2\"&gt;&lt;script&gt;document.getElementById(\"btn2\").attachEvent(\"onclick\",hello);function hello()&#123; alert(\"hello world!\");&#125;&lt;/script&gt; 事件监听的优点1、可以绑定多个事件。1234567891011&lt;input type=\"button\" value=\"click me\" id=\"btn3\"&gt;&lt;script&gt;var btn3 = document.getElementById(\"btn3\");btn3.onclick = function()&#123; alert(\"hello 1\"); //不执行&#125;btn3.onclick = function()&#123; alert(\"hello 2\"); //执行&#125;&lt;/script&gt; 常规的事件绑定只执行最后绑定的事件。 1234567891011121314&lt;input type=\"button\" value=\"click me\" id=\"btn4\"&gt;&lt;script&gt;var btn4 = document.getElementById(\"btn4\");btn4.addEventListener(\"click\",hello1);btn4.addEventListener(\"click\",hello2);function hello1()&#123; alert(\"hello 1\");&#125;function hello2()&#123; alert(\"hello 2\");&#125;&lt;/script&gt; 两个事件都执行了。 2、可以解除相应的绑定123456789101112131415&lt;input type=\"button\" value=\"click me\" id=\"btn5\"&gt;&lt;script&gt;var btn5 = document.getElementById(\"btn5\");btn5.addEventListener(\"click\",hello1);//执行了btn5.addEventListener(\"click\",hello2);//不执行btn5.removeEventListener(\"click\",hello2);function hello1()&#123; alert(\"hello 1\");&#125;function hello2()&#123; alert(\"hello 2\");&#125;&lt;/script&gt; 封装事件监听12345678910111213141516171819202122232425&lt;input type=\"button\" value=\"click me\" id=\"btn5\"&gt;//绑定监听事件function addEventHandler(target,type,fn)&#123; if(target.addEventListener)&#123; target.addEventListener(type,fn); &#125;else&#123; target.attachEvent(\"on\"+type,fn); &#125;&#125;//移除监听事件function removeEventHandler(target,type,fn)&#123; if(target.removeEventListener)&#123; target.removeEventListener(type,fn); &#125;else&#123; target.detachEvent(\"on\"+type,fn); &#125;&#125;//测试var btn5 = document.getElementById(\"btn5\");addEventHandler(btn5,\"click\",hello1);//添加事件hello1addEventHandler(btn5,\"click\",hello2);//添加事件hello2removeEventHandler(btn5,\"click\",hello1);//移除事件hello1 事件委托事件委托就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果。 12345678910&lt;input type=\"button\" value=\"click me\" id=\"btn6\"&gt;var btn6 = document.getElementById(\"btn6\");document.onclick = function(event)&#123; event = event || window.event; var target = event.target || event.srcElement; if(target == btn6)&#123; alert(btn5.value); &#125;&#125; 上面只是个例子，代码尽可能的简化了。在实际的代码中 我们可能用到jQuery的live()、delegate()、bind()、on()等。 事件委托优点1、提高JavaScript性能。事件委托可以显著的提高事件的处理速度，减少内存的占用。实例分析JavaScript中的事件委托和事件绑定，这篇文章写得还不错。 传统写法 123456789101112131415161718192021&lt;ul id=\"list\"&gt; &lt;li id=\"item1\" &gt;item1&lt;/li&gt; &lt;li id=\"item2\" &gt;item2&lt;/li&gt; &lt;li id=\"item3\" &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var item1 = document.getElementById(\"item1\");var item2 = document.getElementById(\"item2\");var item3 = document.getElementById(\"item3\");item1.onclick = function()&#123; alert(\"hello item1\");&#125;item2.onclick = function()&#123; alert(\"hello item2\");&#125;item3.onclick = function()&#123; alert(\"hello item3\");&#125;&lt;/script&gt; 事件委托12345678910111213141516171819202122&lt;ul id=\"list\"&gt; &lt;li id=\"item1\" &gt;item1&lt;/li&gt; &lt;li id=\"item2\" &gt;item2&lt;/li&gt; &lt;li id=\"item3\" &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var item1 = document.getElementById(\"item1\");var item2 = document.getElementById(\"item2\");var item3 = document.getElementById(\"item3\");document.addEventListener(\"click\",function(event)&#123; var target = event.target; if(target == item1)&#123; alert(\"hello item1\"); &#125;else if(target == item2)&#123; alert(\"hello item2\"); &#125;else if(target == item3)&#123; alert(\"hello item3\"); &#125;&#125;)&lt;/script&gt; 2、动态的添加DOM元素，不需要因为元素的改动而修改事件绑定。 传统写法123456789101112131415161718192021222324&lt;ul id=\"list\"&gt; &lt;li id=\"item1\" &gt;item1&lt;/li&gt; &lt;li id=\"item2\" &gt;item2&lt;/li&gt; &lt;li id=\"item3\" &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var list = document.getElementById(\"list\");var item = list.getElementsByTagName(\"li\");for(var i=0;i&lt;item.length;i++)&#123; (function(i)&#123; item[i].onclick = function()&#123; alert(item[i].innerHTML); &#125; &#125;)(i)&#125;var node=document.createElement(\"li\");var textnode=document.createTextNode(\"item4\");node.appendChild(textnode);list.appendChild(node);&lt;/script&gt; 点击item1到item3都有事件响应，但是点击item4时，没有事件响应。说明传统的事件绑定无法对动态添加的元素而动态的添加事件。 事件委托12345678910111213141516171819202122&lt;ul id=\"list\"&gt; &lt;li id=\"item1\" &gt;item1&lt;/li&gt; &lt;li id=\"item2\" &gt;item2&lt;/li&gt; &lt;li id=\"item3\" &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var list = document.getElementById(\"list\");document.addEventListener(\"click\",function(event)&#123; var target = event.target; if(target.nodeName == \"LI\")&#123; alert(target.innerHTML); &#125;&#125;)var node=document.createElement(\"li\");var textnode=document.createTextNode(\"item4\");node.appendChild(textnode);list.appendChild(node);&lt;/script&gt; 当点击item4时，item4有事件响应。说明事件委托可以为新添加的DOM元素动态的添加事件。","tags":[{"name":"Arguments","slug":"Arguments","permalink":"http://qianniuer.github.io/tags/Arguments/"}]},{"title":"Arguments对象作用深度研究","date":"2016-04-16T08:37:46.000Z","path":"2016/04/16/Arguments对象作用深度研究/","text":"每个函数都会有一个Arguments对象实例arguments，它引用着函数的实参，可以用数组下标的方式”[]”引用arguments的元素。arguments.length为函数实参个数，arguments.callee引用函数自身。 Arguments对象介绍Arguments对象是一个伪数组对象，它有length属性，可以arguments[i]来访问对象中的元素，但它不能用数组的一些方法，例如push，pop，slice等。 Arguments的length属性Arguments的length属性，表示function函数实际所传参数的个数。函数名点length可以获取函数期望的传参个数。 1234567891011function argTest(a,b,c)&#123; var t = arguments.length; //实际传参个数 var e = argTest.length; //期望传参个数 console.log(t); console.log(e);&#125;argTest(11,12); //t=2,e=3argTest(11,12,13); //t=3,e=3argTest(11,12,13,14); //t=4,e=3 Arguments的参数访问Arguments对象的参数访问可以用arguments[i]来访问函数所传的参数。 1234567891011function argTest(a,b,c)&#123; var arg = []; for(var i=0;i&lt;arguments.length;i++)&#123; arg.push(arguments[i]); &#125; console.log(arg);&#125;argTest(11,12); //[11, 12]argTest(11,12,13); //[11, 12, 13]argTest(11,12,13,14); //[11, 12, 13, 14] Arguments的callee调用Arguments的callee属性可以调用函数本身，当函数正在执行时才可调用，可以实现方法的递归调用。 123456function argTest(a,b,c)&#123; var e = arguments.callee.toString(); console.log(e);&#125;argTest(); //打印出函数本身 Function对象caller属性Function对象的caller属性可以指向当前函数的调用者，当调用者函数正在执行时才可调用， 123456789101112131415161718192021function callerTest()&#123; if(callerTest.caller)&#123; var caller = callerTest.caller.toString(); console.log(caller); &#125;else&#123; console.log(\"no caller\") &#125;&#125;function handler()&#123; callerTest();&#125;function handlerToHandler()&#123; handler();&#125;callerTest(); //no callerhandler(); //返回调用者handler函数handlerToHandler(); //返回调用者handler函数 Arguments的作用方法重载方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。Javascript并没有重载函数的功能，但是Arguments对象能够模拟重载。 123456789101112131415//普通方法实现方法重载function test(a,b,c)&#123; if(a &amp;&amp; b &amp;&amp; c)&#123; console.log(a + b + c); &#125;else if(a &amp;&amp; b)&#123; console.log(a + b); &#125;else&#123; console.log(a); &#125;&#125;test(); //undefinedtest(11,12); //23test(11,12,13) //36 12345678910111213//Arguments对象实现方法重载function test()&#123; var sum = 0; for(var i=0;i&lt;arguments.length;i++)&#123; sum += arguments[i]; &#125; console.log(sum);&#125;test(); //0test(11,12); //23test(11,12,13); //36 12345678910111213//ES6实现方法重载function test(...nums)&#123; var sum = 0; for(var i=0;i&lt;nums.length;i++)&#123; sum += nums[i]; &#125; console.log(sum);&#125;test(); //0test(11,12); //23test(11,12,13); //36 递归调用这样的好处就是可以实现匿名函数的递归调用。 123456789101112//实现一个阶乘函数function factorial(n)&#123; if(n == 1)&#123; return 1; &#125;else&#123; n * arguments.callee(n-1); &#125;&#125;factorial(1); //1factorial(5); //120 不定参问题比如说，我想判断你传给我的一些数字的大小，取出最大的那个 123456789101112function max()&#123; var maxNum = Number.NEGATIVE_INFINITY;; for(var i=0;i&lt;arguments.length;i++)&#123; if(arguments[i]&gt; maxNum)&#123; maxNum = arguments[i]; &#125; &#125; return maxNum;&#125;max(1,2,3,11,4,10); //11max(2,-10,22,11); //22","tags":[{"name":"Arguments","slug":"Arguments","permalink":"http://qianniuer.github.io/tags/Arguments/"}]},{"title":"JS的原型和原型链","date":"2016-04-16T08:37:46.000Z","path":"2016/04/16/JS的原型和原型链/","text":"在JavaScript的使用过程中，我们经常会遇到prototype，可能了解一点，它是一个对象的原型，用来做原型继承的。这样去理解就有点不准确了，今天就让我们深入的去了解它。 了解一些概念在读这篇文章之前，你应该去在自己的脑海问几个问题：1、什么是原型？2、什么事原型链？3、prototype与__proto__有什么不同，有什么联系？4、constructor与面两个有什么联系，怎么用？ 如果你把上面这四个问题都解决了，那你就真正了解了JS的原型和原型链。接下来，咱们一个一个问题去解决。 什么是原型JavaScript 中，万物皆对象！但对象也是有区别的。分为普通对象和函数对象，Object ，Function 是JS自带的函数对象。每个对象都有原型（null和undefined除外），你可以把它理解为对象的默认属性和方法。 你可以把下面的代码在浏览器打印出来看一下。 1234567891011121314console.log(Object.prototype); //Object&#123;&#125;var o = new Object();console.log(o.prototype); //undefinedconsole.log(Array.prototype); //[Symbol(Symbol.unscopables): Object]console.log(Function.prototype); //function()&#123;&#125;function hello()&#123; console.log(\"hello\");&#125;hello.prototype = \"hello world\";console.log(hello.prototype); //hello world Object：Object是一个函数对象，Object的原型就是一个Object对象，它里面存在着一些对象的方法和属性，例如最常见的toString方法。 新建对象：用new Object或者{}建的对象是普通对象，它没有prototype属性，只有__proto__属性，它指向Object.prototype。 Array：Array也是一个函数对象，它的原型就是Array.prototype，它里面存在着一些数组的方法和属性，例如常见的push，pop等方法。 Function：Function也是一个函数对象，但它有点特殊，它的原型就是一个function空函数。 自定义函数：它的原型就是你给它指定的那个东西。如果你不指定，那它的原型就是一个Object.prototype。 什么是原型链在 javaScript 中，每个对象都有一个指向它的原型（prototype）对象的内部链接。这个原型对象又有自己的原型，直到某个对象的原型为 null 为止（也就是不再有原型指向），组成这条链的最后一环。这种一级一级的链结构就称为原型链（prototype chain）。 JavaScript 对象是动态的属性“包”（指其自己的属性）。JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依此层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。 12345678910var o = &#123; a:1, b:2&#125;;console.log(o.toString()); //不报错，o上没有toString方法，但是Object上有console.log(o.push(\"c\")); //报错，o上没有这个方法，Object上也没有这个方法。console.log(o.a); //1console.log(o.c); //undefined 当你用new Object或者直接定义一个对象时，它的原型链就是：o ==》 Object.prototype ==》 null但你访问o上没有的属性或方法时，JS会往Object.prototype上寻找该属性和方法。如果有则直接返回，如果没有，方法则报错，这个方法未定义，属性则返回undefined。 12345678910function Person(name)&#123; this.name = name;&#125;Person.prototype = &#123;age:24&#125;;var tsrot = new Person(\"tsrot\");console.log(tsrot.name); //tsrotconsole.log(tsrot.age); //24console.log(tsrot.toString()); //[object Object] 当你用构造函数（构造函数我们一般首字母大写）建立一个对象时，它的原型链就是：tsrot ==》 Person.prototype ==》 Object.prototype ==》 null如果没有定义Person.prototype这一环，则直接跳到下一环。 来点更复杂的。1234567891011121314151617function Parent()&#123; this.name = \"i am parent\";&#125;Parent.prototype = &#123;age:24&#125;;function Child()&#123; this.name = \"i am child\";&#125;Child.prototype = Object.create(Parent.prototype); //让Child的原型指向Parent的原型Child.prototype.constructor = Child; //把child的构造函数指向回来，否则它将指向Parent。虽然在这没什么影响，但要养成代码的严谨性var child = new Child();console.log(child.name); //i am childconsole.log(child.age); //24console.log(child.toString()); //[object Object] 当你需要父类的属性和方法时，你可以把它的原型指向父类的原型。此时的原型链就是：child ==》 Parent.prototype ==》 Object.prototype ==》 null 12345var arr = [1,2,3];console.log(arr); //[1,2,3]arr.push(4);console.log(arr); //[1,2,3,4] 数组也是一个对象，不过它是由Array构造函数new而来的，所以它的原型链就是：arr ==》 Array.prototype ==》 Object.prototype ==》 null 12345var fun = function()&#123; var hello = \"i am function\";&#125;console.log(fun.name); //fun fun是一个函数对象，它是由Function构造函数new而来的，所以它的原型链就是：fun ==》 Function.prototype ==》 Object.prototype ==》 nullfun它没有name属性，但是Function它有，所以这个name就是Function原型上的。 prototype与__proto__在Javascript中，每个函数都有一个原型属性prototype指向自身的原型，而由这个函数创建的对象也有一个__proto__属性指向这个原型，而函数的原型是一个对象（函数点prototype也是一个普通对象，Function.prototype除外,它是函数对象，但它很特殊，他没有prototype属性），所以这个对象也会有一个__proto__指向自己的原型，这样逐层深入直到Object对象的原型，这样就形成了原型链。普通对象没有prototype，但有__proto__属性。 1234567891011function f1()&#123;&#125;;console.log(f1.prototype) //Object&#123;&#125;console.log(typeof f1.prototype) //Objectconsole.log(typeof Function.prototype) // Function，这个特殊console.log(typeof Object.prototype) //Objectconsole.log(typeof Function.prototype.prototype) //undefined JS在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做__proto__的内置属性，用于指向创建它的函数对象的原型对象prototype。 普通对象的__proto__12345var o = &#123;name:\"tsrot\"&#125;;console.log(o.__proto__); //Object&#123;&#125;console.log(o.prototype); //undefinedconsole.log(o.__proto__ === Object.prototype); //true 构造对象的__proto__123456789101112131415161718192021function Parent()&#123; this.name = \"i am parent\";&#125;Parent.prototype = &#123;age:24&#125;;function Child()&#123; this.name = \"i am child\";&#125;Child.prototype = Object.create(Parent.prototype);Child.prototype.constructor = Child;var child = new Child();console.log(child.__proto__); //Object&#123;&#125;console.log(Child.prototype); //Object&#123;&#125;console.log(child.__proto__ === Child.prototype); //trueconsole.log(Parent.prototype.__proto__ === Object.prototype); //true 数组的__proto__1234567var arr = [1,2,3];console.log(arr.__proto__); //[Symbol(Symbol.unscopables): Object]console.log(Array.prototype); //[Symbol(Symbol.unscopables): Object]console.log(arr.__proto__ === Array.prototype); //true 函数的__proto__12345678910111213var fun = function()&#123; var hello = \"i am function\"&#125;fun.prototype = &#123;name:\"tsrot\"&#125;;console.log(fun.prototype); //Object &#123;name: \"tsrot\"&#125;console.log(fun.__proto__); //function()&#123;&#125;console.log(fun.prototype === fun.__proto__); //falseconsole.log(fun.__proto__ === Function.prototype); //true constructor属性原型对象prototype中都有个预定义的constructor属性，用来引用它的函数对象。这是一种循环引用： 123456789function Person(name)&#123; this.name = name;&#125;console.log(Person.prototype.constructor === Person); //trueconsole.log(Function.prototype.constructor === Function); //trueconsole.log(Object.prototype.constructor === Object); //true 用构造函数创建的对象，它的constructor属性就是它的构造函数。1234567function Person(name)&#123; this.name = name;&#125;var person = new Person();console.log(person.constructor === Person); //true 参考文章1、JavaScript Prototype Chains2、Understanding JavaScript Prototypes3、继承与原型链","tags":[{"name":"原理","slug":"原理","permalink":"http://qianniuer.github.io/tags/原理/"}]},{"title":"思维习惯","date":"2016-03-25T13:04:35.000Z","path":"2016/03/25/思维习惯/","text":"聪明人是如何思考问题的？ 近三四百年来，人们一直在反思更加有效的思考模式：我们究竟应当如何看世界,怎样思考问题。 从问题到答案，从原因到结果，从对称到不对称，从思辨到相对，从观察到实验，从期待到途径…… 不管是黑格尔还是康德，再到尼采，海德格尔，弗洛伊德，似乎都未找到真正的出路。无数多的先贤曾下工夫去探索答案，期望能给迷茫的人们以答案。１、任何事情都有因果。 因果构成世界，“因”决定“果”。任何的结果都有一个、几个甚至更多的因，我想，只要找到了“因”，就可以掌握“果”。理论上，是成立的，但由于世界是复杂的，任何一个“果”可能会有很多的“因”约束，比如命运，“命”不可控制，但“运”可以控制，控制“运”的方法，就是找到真正的“因”，找到真正的因的方法就是，设法减去次要的“因”。２、方式和角度决定结论。 不同的思考方法，不同的观察角度，会决定不同的结果。在我们的习惯性思维控制下，我们经常顾此失彼。当我们观察和思考一个事物的时候，经常出现偏颇，不是我们没看到而是我们的感知不到，心中没有眼里就没有。 所以，我们最好的选择是，调整和改变思考和观察的方法，直到一个自己觉得比较舒适的位置，总会有一个较为客观的世界，呈现在我们的面前。３、任何事物的发展都是呈阶梯状的。比如，人往高处走，怎么走？拾“级”才能上。阶梯是规律，更是方法。在所有的规律中，该规律的独特价值是，将理论与实践结合在了一起。一切的成功都应归结为目标的达成。对目标进行细化、量化、具体化的过程，就是形成阶梯的过程!４、哲学不是处世技术，而是一种爱智慧，更是一种关怀世界的方式。 不要寄希望于哲学能提供给你一套处世技术。 哲学只是一种爱智，其核心是终极关怀，是对彼岸世界的一种信念，一种坚持。哲学对生活的启迪应当是文化意义上的启迪，而启迪的过程就是把人本身作为根本追求的过程。当然，哲学并不是枯燥的，反而是灵动的，是诗性的，是美丽的，是开心的。从某一个角度上看，每一个人都是哲学家，因为，我们每天都在感悟。感悟是哲学对人的最基本要求。 ５、问题经常是在我们试图解决它的时候发生。 很多心理学家认为，心理学上有些事情是因为我们去解决它们才构成问题。比如抑郁症，我们创造了抑郁症这个词，抑郁就开始流行。因为我们大脑里有了，生活中我们就真正找到了证据。再比如孤独，我们意识到自己的言行符合孤独的概念时，我们的孤独感随之袭来。 概念和定义对人们的利益是显而易见的，但危害也是显而易见的。 ６、世界的很多东西，我们永远分不清楚，是混沌的。但我们可以调整自己的高度来解释自己。 统一的身后一定隐藏着分裂，和谐的身后一定隐藏着冲突，爱的身后一定隐藏着恨。 但，我们经常会发现，当我们站在一个层级看问题的时候，我们发现事物是对立的，当我们站在一定更高的高度看时，发现事物是和谐的，对立双方是并存的、互补的。我对如何形成自己的高度，曾经做过论述： 一是处理好整体与局部之间的关系： （1）整体大于各部分之和； （2）任何一个整体都是另外一个整体的局部，而任何一个局部都是另外一个局部的整体。毛主席说：大道理管中道理，中道理管小道理。 二是处理好三个思考层面之间的关系： （1）感性层面； （2）理性层面； （3）悟性层面。 人的高度从第一层面起步，到第二层面，然后到第三层面。最后返朴归真，融会贯通。 三是处理好理论与实践之间的关系： （1）任何“高度”都是来源于一线的实践，又抽象于一线的实践。没有务实的精神和抽象的方法，不可能有高度。我原来的同事、著名经济学家温铁军先生曾反复谈论过——怎样用脚做学问，现在想来更感难得。 （2）将思想系统化，形成理论，理论高于思想，但必须经过实践验证。 训练题(注:这12道题目主要训练的是人在分析问题时的思维韧性，一个人的思维就像人的韧带，越是训练，越是轻松自由。) 1、父子二人经过五星级饭店门口，看到一辆十分豪华的进口轿车。儿子不屑地对他的父亲说：「坐这种车的人，肚子里一定没有学问！」父亲则轻描淡写地回答：「说这种话的人，口袋里一定没有钱！」 （注：一个人对事情的看法，经常反映的是他的内心态度，态度决定一切，态度的核心是自主选择） 2、晚饭后，母亲和女儿一块儿洗碗盘，父亲和儿子在客厅看电视。突然，厨房里传来打破盘子的响声，然后一片沉寂。是儿子望着他父亲，说道：「一定是妈妈打破的。」「你怎么知道？」「她没有骂人。」 （注：我们习惯以不同的标准来看人看己，以致往往是责人以严，待己以宽。） 3、有两个台湾观光团到日本伊豆半岛旅游，路况很坏，到处都是坑洞。其中一位导游连声抱歉，说路面简直像麻子一样。说而另一个导游却诗意盎然地对游客说：诸位先生女士，我们现在走的这条道路，正是赫赫有名的伊豆迷人酒窝大道。」 （注：虽是同样的情况，然而不同的角度，就会产生不同的态度。思想是何等奇妙的事，如何去想，决定权在你。） 4、同样是小学三年级的学生，在作文中说他们将来的志愿是当小丑。中国的老师斥之为：「胸无大志，孺子不可教也！」，外国的老师则会说：「愿你把欢笑带给全世界！」 （注：身为长辈的我们，不但容易要求多于鼓励，更狭窄的界定了成功的定义。） 5、在故宫博物院中，有一个太太不耐烦地对她先生说：「我说你为甚么走得这么慢。原来你老是停下来看这些东西。」（注：有人只知道在人生的道路上狂奔，结果失去了观看两旁美丽花朵的机会。） 6、妻子正在厨房炒菜。丈夫在她旁边一直唠叨不停：慢些。小心！火太大了。赶快把鱼翻过来。快铲起来，油放太多了！把豆腐整平一下！「哎？」妻子脱口而出，「我懂得怎样炒菜。」「你当然懂，太太，」丈夫平静地答道：「我只是要让你知道，我在开车时，你在旁边喋喋不休，我的感觉如何。」 （注：学会体谅他人并不困难，只要你愿意认真地站在对方的角度和立场看问题。） 7、一辆载满乘客的公共汽车沿着下坡路快速前进着，有一个人后面紧紧地追赶着这辆车子。一个乘客从车窗中伸出头来对追车子的人说：“老兄！算啦，你追不上的！”“我必须追上它，”这人气喘吁吁地说：“我是这辆车的司机！” （注：有些人必须非常认真努力，因为不这样的话，后果就十分悲惨了！然而也正因为必须全力以赴，潜在的本能和不为人知的特质终将充份展现出来。） 8、甲：「新搬来的邻居好可恶，昨天晚上三更半夜、夜深人静之时然跑来猛按我家的门铃。」 乙：「的确可恶！你有没有马上报警？」 甲：「没有。我当他们是疯子，继续吹我的小喇叭。」 （事出必有因，如果能先看到自己的不是，答案就会不一样在你面对冲突和争执时，先想一想是否心中有亏，或许很快就能释怀了） 9、某日，张三在山间小路开车，正当他悠哉地欣赏美丽风景时，突然迎面开来一辆货车，而且满囗黑牙的司机还摇下窗户对他大骂一声：“猪！”张三越想越纳闷，也越想越气，於是他也摇下车窗回头大骂：“你才是猪”才刚骂完，他便迎头撞上一群过马路的猪。 （不要错误的诠释别人的好意，那只会让自己吃亏，并且使别人受辱。在不明所以之前，先学会按捺情绪，耐心观察，以免事后生发悔意。） 10、小男孩问爸爸：“是不是做父亲的总比做儿子的知道得多？” 爸爸回答：“当然啦！” 小男孩问：“电灯是谁发明的？” 爸爸：“是爱迪生。” 小男孩又问：“那爱迪生的爸爸怎麽没有发明电灯？”（很奇怪，喜欢倚老卖老的人，特别容易栽跟斗。权威往往只是一个经不起考验的空壳子，尤其在现今这个多元开放的时代。） 11．小明洗澡时不小心吞下一小块肥皂，他的妈妈慌慌张张地打电话向家庭医生求助。医生说：“我现在还有几个病人在，可能要半小时后才能赶过去。”小明妈妈说：“在你来之前，我该做甚麽？” 医生说：“给小明喝一杯白开水，然后用力跳一跳，你就可以让小明用嘴巴吹泡泡消磨时间了。”（take it easy，放轻松放轻松些，生活何必太紧张？事情既然已经发生了，何不坦然自在的面对。担心不如宽心，穷紧张不如穷开心。） 12、一把坚实的大锁挂在大门上，一根铁杆费了九牛二虎之力，还是无法将它撬开。钥匙来了，他瘦小的身子钻进锁孔，只轻轻一转，大锁就“啪”地一声打开了。 铁杆奇怪地问：“为什麽我费了那麽大力气也打不开，而你却轻而易举地就把它打开了呢？”钥匙说：“因为我最了解他的心。” （每个人的心，都像上了锁的大门，任你再粗的铁棒也撬不开。唯有关怀，才能把自己变成一只细腻的钥匙，进入别人的内心，了解别人。）","tags":[{"name":"思考","slug":"思考","permalink":"http://qianniuer.github.io/tags/思考/"},{"name":"学习","slug":"学习","permalink":"http://qianniuer.github.io/tags/学习/"}]},{"title":"《你只是看起来很努力》","date":"2016-01-17T02:55:34.000Z","path":"2016/01/17/《你只是看起来很努力》/","text":"对这个世界来说，没有什么果是没有因的，即使现在因看不出来，但也一定是存在的。 骗别人很容易，骗自己更容易，可是，骗这个世界的因果，有点难。 学习之前，你有没有制定计划，告诉自己今天我要学到什么；背下来什么；掌握什么能力。没有目标的努力，没有计划的奋斗，都只是作秀而已。 《你只是看起来很努力》，看完序章，就有了买书的冲动。 努力，是一个私人的事情，需要踏实、坚持、心无旁骛。任何一个领域，想要超越别人，成为专家，都要付出别人无法付出的努力。这种努力，不是心血来潮，不是一纸计划单。而是知行统一，专注、投入、热爱、癫狂、疯魔。 很自然的，想到了考研。我一直以为，自己已经非常努力。现在想想，当时的我，并没有真正倾尽全力。以劳逸结合的借口，还有时间看非诚勿扰，还有时间关注新闻，还有时间熬夜刷贴吧。。。艾佳生活，一位面试我的前辈，他以前也考研，准备了三个月，每天早6晚12，考研成功。。。不疯魔不成活！再给我一次机会，我能考好吗？不一定！但是，把握会更大！ 前人说，不逼自己一把，你永远不知道自己有多么优秀！如果一件事，没有危及到自身的利益，没有让我们羡慕嫉妒恨，我们总是不急着去做。知道锻炼重要，但只有生病的时候，才会下定决心好好锻炼，保持健康；知道健身有益，但只有看到身边的人秀胸肌腹肌的时候，才会因为羡慕嫉妒而去健身；喜欢技术，但只有当这门技术决定前途命运的时候，才会开始用心学习；喜欢钢琴，但只有看到别人十指轻舞的时候，才会再次告诉自己，该去学琴了。。。当危机过去，当热情过去，有多少人，还会继续锻炼、健身、学技术、学钢琴？ 机会给有准备的人，而不是给机会来了再去准备的人。厚积薄发，在别人背后偷偷努力，变得优秀，变得卓越，才是一个真正上进的人！ 有些事情，不着急，但是更重要。比如孝顺，比如爱情，比如旅行，比如阅读。。。生命不知道何时休止，要考虑清楚，这一生有哪些事情是必须要做，优先要做的。","tags":[{"name":"励志","slug":"励志","permalink":"http://qianniuer.github.io/tags/励志/"}]},{"title":"Githup-hexo生成博客","date":"2016-01-06T02:37:46.000Z","path":"2016/01/06/Githup-hexo生成博客/","text":"体验更加排版请访问原文链接：http://blog.liuxianan.com/build-blog-website-by-hexo-github.html 使用github pages服务搭建博客的好处有：123456- 全是静态文件，访问速度快；- 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；- 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；- 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；- 博客内容可以轻松打包、转移、发布到其它平台；- 等等； 准备工作 在开始一切之前，你必须已经：有一个github账号，没有的话去注册一个；安装了node.js、npm，并了解相关基础知识；安装了git for windows（或者其它git客户端）本文所使用的环境： Windows8.1node.js@5.5.0git@1.9.2hexo@3.2.2 搭建Githup博客###创建仓库新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了，是不是很方便？ 由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 几个注意的地方： 注册的邮箱一定要验证，否则不会成功；仓库名字必须是：username.github.io，其中username是你的用户名；仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效；创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。 ###绑定域名当然，你不绑定域名肯定也是可以的，就用默认的 xxx.github.io 来访问，如果你想更个性一点，想拥有一个属于自己的域名，那也是OK的。 首先你要注册一个域名，域名注册以前总是推荐去godaddy，现在觉得其实国内的阿里云也挺不错的，价格也不贵，毕竟是大公司，放心！ 绑定域名分2种情况：带www和不带www的。 域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下你的用户名.github.io的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向你的用户名.github.io，这样可以保证无论是否添加www都可以访问，如下： 然后到你的github项目根目录新建一个名为CNAME的文件（无后缀），里面填写你的域名，加不加www看你自己喜好，因为经测试： 如果你填写的是没有www的，比如 mygit.me，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://mygit.me如果你填写的是带www的，比如 www.mygit.me ，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://www.mygit.me如果你填写的是其它子域名，比如 abc.mygit.me，那么访问 http://abc.mygit.me 没问题，但是访问 http://mygit.me ，不会自动跳转到 http://abc.mygit.me另外说一句，在你绑定了新域名之后，原来的你的用户名.github.io并没有失效，而是会自动跳转到你的新域名。 ##配置SSH key为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。1$ cd ~/. ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。1ssh-keygen -t rsa -C &quot;邮件地址&quot; 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： ##测试是否成功1$ ssh -T git@github.com # 注意邮箱地址不用改 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：1Hi liuxianan! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！ 此时你还需要配置：12$ git config --global user.name &quot;liuxianan&quot;// 你的github用户名，非昵称$ git config --global user.email &quot;xxx@qq.com&quot;// 填写你的github注册邮箱 ##使用hexo写博客 ###hexo简介Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。 官网： http://hexo.iogithub: https://github.com/hexojs/hexo ###原理由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 ###注意事项安装之前先来说几个注意事项： 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行； hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导； hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的； ###安装1$ npm install -g hexo ###初始化在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是F:\\Workspaces\\hexo，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。12$ cd /f/Workspaces/hexo/$ hexo init hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：12$ hexo g # 生成$ hexo s # 启动服务 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的： hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章： http://blog.liuxianan.com/windows-port-bind.html 第一次初始化的时候hexo已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑 ###修改主题既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 官方主题。 个人比较喜欢的2个主题：hexo-theme-jekyll 和 hexo-theme-yilia。 首先下载这个主题：12$ cd /f/Workspaces/hexo/$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia ###下载后的主题都在这里：修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。 如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。 ###上传之前在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。 ###上传到github如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。 首先，ssh key肯定要配置好。 其次，配置_config.yml中有关deploy的部分： 正确写法：1234deploy: type: git repository: git@github.com:liuxianan/liuxianan.github.io.git branch: master 错误写法：1234deploy: type: github repository: https://github.com/liuxianan/liuxianan.github.io.git branch: master 后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行hexo d的话一般会报如下错误： 1Deployer not found: github 或者 Deployer not found: git 原因是还需要安装一个插件：1npm install hexo-deployer-git --save 其它命令不确定，部署这个命令一定要用git bash，否则会提示Permission denied (publickey). 打开你的git bash，输入hexo d就会将本次有改动的代码全部提交，没有改动的不会： ###保留CNAME、README.md等文件提交之后网页上一看，发现以前其它代码都没了，此时不要慌，一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的： 由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。 ###常用hexo命令 ####常见命令1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 ####缩写：1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy ####组合命令：12hexo s -g #生成并本地预览hexo d -g #生成并上传 ###_config.yml这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。 ##写博客定位到我们的hexo根目录，执行命令：1hexo new &apos;my-first-blog&apos; hexo会帮我们在_posts下生成相关md文件：我们只需要打开这个文件就可以开始写博客了，默认生成如下内容：当然你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。一般完整格式如下： 12345title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面 那么hexo new page ‘postName’命令和hexo new ‘postName’有什么区别呢？1hexo new page &quot;my-second-blog&quot; 生成如下：最终部署时生成：hexo\\public\\my-second-blog\\index.html，但是它不会作为文章出现在博文目录。 ###写博客工具 那么用什么工具写博客呢？这个我还没去找，以前自己使用editor.md简单弄了个，大家有好用的hexo写博客工具可以推荐个。 如何让博文列表不显示全部内容 默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？ 答案是在合适的位置加上即可，例如： 12345678910111213#前言使用github pages服务搭建博客的好处有：1. 全是静态文件，访问速度快；2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；&lt;!--more--&gt;4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；5. 博客内容可以轻松打包、转移、发布到其它平台；6. 等等；","tags":[{"name":"博客","slug":"博客","permalink":"http://qianniuer.github.io/tags/博客/"}]},{"title":"自由与理想","date":"2015-04-19T02:20:06.000Z","path":"2015/04/19/自由与理想/","text":"作者：吴晓波 在我们这个国家，最昂贵的物品是自由与理想。它们都是具体的，都是不可以被出卖的，而自由与理想，也不可以被互相出卖。 我进大学听的第一次大型讲座，是在复旦四号楼的阶梯教室，因为到的迟了，教室里满满当当都是人，我只能挂在铁架窗台上，把脖子拼命往里伸。那时是 1980 年代中期，存在主义刚刚如同幽灵般地袭入激变中的中国。 一位哲学系的青年讲师站在台上，他大声说，上帝死了。 如今想来，我成为一个具有独立意识的人，大抵是在那个复旦秋夜，我不再隶属于任何意识形态、任何组织或机构，甚至国家。我是一个属于自己的读书人。“无事袖手谈性情，有难一死报君王。”这段诗句也是大学图书馆里读到的，不记得是哪本书了，但是过目即不忘，耿耿于怀。当时就想，中国书生的千年局促与荒诞就在这十四个字里了，我们这一辈应该学习做一个“没有君王的书生”。 在大学这样的“真空状态”下，当一个思想自由的读书人似乎是容易的，你对社会无所求，社会与你亦无所扰。可是出了校门，后来的二十多年，却是一天接一天的不容易。 大学毕业是 1990 年。这个国家好像一夜之间被推进了商品化的潮流中，大概是在 1992 年前后，一位熄灯之后阔谈康德和北岛的上铺同学，突然给我打电话，说他在新疆能弄到上好的葡萄干，如果在南方找到通路，可以发一笔上万元的大财。又过几周，一位厦门的同学来信，说杭州海鲜市场的基围虾都是从厦门空运的，问我能不能联系一个下家。去电视机厂采访，厂长从上衣口袋里掏出一张盖了圆章的条子，凭这个买彩电可以便宜 300 元，相当于我两个月的工资。 还有一次，陪一位饮料公司老板见市里的副市长。副市长一表人才，气傲势盛。两方坐定，老板突然从包里摸出一台半块砖头大小的摩托罗拉移动手机，小心翼翼地树在茶几前，副市长第一次亲眼目睹此物——在当年它相当于高级公务员十年工资，我分明感觉到他的气势硬生生地被压下了半头。 那个年轻的我，握着一管钢笔的书生，夹在政商之间，猛然又想起性情与君王。 到了年底，单位把大家召集起来，谈明年的工作目标。轮到发言，我说，明年的目标是挣到 5000 元稿费，做“半个万元户”。四座的叔婶辈们齐齐把无比诧异的目光射向坐在墙角的我。 后来的几年里，疯狂地写稿子，为单位写，为单位外的报纸、电台写，为企业写新闻通稿、汇报材料、讲话稿甚至情况说明，为广告公司写报纸文案、电视广告脚本，再然后，写专栏、写书，一本接一本地写书。 那些年，我开始信奉这样一句格言——“作为知识分子，你必须有一份不以此为生的职业”，罗斯福的这句话里有一种决然的挣脱，它告诫我，读书人应摆脱对任何外部组织的人身和物质依附，同时，其职业选择应该来自兴趣和责任，而与生存无关。这是一种来自西方的价值观，最远可追溯到亚里士多德，他将具有道德行为能力的人局限于“有产男性公民”，即“无恒产则不自由，不自由则无道德”。在一个一切均可以用财富量化评估的商业社会里，思想自由不再是一个哲学名词，而是一种昂贵的生存姿态，它应基础于财富的自由。 1990年代末，房地产业悄然趋暖，在财经世界浸淫多年的我，对照欧美和亚洲列国的经验，意识到这将是一个长期行情，而一生中也许只能经历一次。于是，我将几乎所有的稿费积蓄都投掷于购房。这是一个特别单纯的行动，无需寻租、无需出卖。你只要有勇气和懂一些货币杠杆的知识，购入即持有，持有即出租，一有机会便抵押套现，再复循环，财富如溪入壑，水涨船高。 2003年，我决定离开服务了十三年的单位。那时是中国财经媒体的黄金时代，我设想创办国内第一份商业周刊，在此前的 2001 年，我已经写出《大败局》，在商界有了一些信誉，有人愿意掏钱投资，有 4A 公司愿意入股并包销所有广告，我把这些资源打包成一份创业计划书，与至少三家省级报业集团洽谈刊号，不出预料的是，他们都表达了极大的兴趣，但无一例外的是，他们都以国家政策为由，提出控股的要求，有一家集团表示可以让民间持有 49% 的股份，“剩下的 1% 实在不能让出来。” 但在我看来，那剩下的 1% 就是自由的边疆。 最后，我放弃了商业周刊的计划。因为，书生不能有“君王”，即便为了理想，也不行。 不能办杂志，不能办电视台、不能办报纸，但我除了办媒体又不会干别的，于是，最后只剩下一条出路：办出版。 出版的书号也是牌照资源，但它有一个“半公开”的交易市场。 有交易，就有自由，而只有自由前提下的理想才值得去实现。 于是，有了蓝狮子。从第一天起，它的股东就全数为私人。 十年以来，我一直被蓝狮子折磨。就商业的意义上，出版是一个毛利率超低、账期极长、退货率让人难以忍受的“烂行业”，在当今的三百六十行，只有它还在“先铺货，后收款”。在很长时间里，蓝狮子名声在外，但规模和效益却强差人意。不过，我却从来没有后悔和沮丧过，因为它是我的理想，而且是一个可以被掌控的理想，更要紧的是，与我的众多才华横溢的朋友们相比，我没有为了理想，出卖我的“资本自由”。 浮生如梦，这一路走来三步一叹，别别扭扭。 在我们这个国家，最昂贵的物品是自由与理想。它们都是具体的，都是不可以被出卖的，而自由与理想，也不可以被互相出卖。 自由是世俗的，它不在空中，不在别处，它就在地上。作为一个读书人，你能否自由地支配时间，你能否自由地选择和放弃职业，你能否自由地在四月去京都看樱花，你能否自由地与富可敌国的人平等对视，你能否自由地抵制任何利益集团的诱惑，这一切并不仅仅是心态或勇敢的问题，而是一种现实能力。 与自由相比，理想则是一个人的自我期许和自我价值呈现的方式。千百年来，无数中国读书人为了理想以身相许，他们把自由出卖给帝王、党派或豪门，试图以此换取自我价值的实现。在我看来，这是不值得的。理想是一个“人生的泡沫”，可大可小，可逐步实现，也可以不实现，但是，自由不可须臾缺失。加缪在《西西弗神话》中论及“人的荒诞性”，曾说，“一个人始终是自己真理的猎物，这些真理一旦被确认，他就难以摆脱。” 那么，一个人能否拥有与之制衡的能力？ 加缪提供了三个结果：我的反抗、我的自由和我的激情。","tags":[{"name":"读者","slug":"读者","permalink":"http://qianniuer.github.io/tags/读者/"},{"name":"吴晓波","slug":"吴晓波","permalink":"http://qianniuer.github.io/tags/吴晓波/"}]},{"title":"驯服你的大脑","date":"2014-12-09T10:06:13.000Z","path":"2014/12/09/驯服你的大脑/","text":"慢慢来，理解越多，越不需要强记 别只顾着翻页，记得停下来，好好思考。书中提出的问题，别完全不思考就直接看答案。想象是另外一个人面对面地向你提问，如果能够强迫大脑思考得更深入，就越有机会理解并记得更多的知识。 勤做练习，写下心得 学以致用才能掌握知识点，实践之后，写下心得，最好在博客上。之后哪怕遗忘，也能很快记忆起来。 多提问 联想，思考，会产生很多问题。在解决问题的过程中，你会学到很多东西。 将读书作为睡前最后一件事，至少是睡前最后一件具有挑战性的活动 学习的一部分反应（特别是转化为长期记忆的过程）发生在放下书本之后。你的大脑需要进一步处理新知识的时间。如果处理期间塞进其他新知识，某些刚学过的东西将会遗失。 喝水，多喝水 你的大脑需要浸泡在丰沛的液体内，才能运作良好，脱水（往往发生在感觉口渴前）会减缓认知功能。 念出声音，大声念出来 “说话”将驱动大脑的不同部位。如果需要理解某项事物或试图增强记忆，请大声说出来，解释给别人听的效果更佳。你会学的更快，甚至触发许多新想法，光靠阅读无法有这种效果。 倾听大脑的声音 注意你的大脑是否过度负荷，如果你发现自己开始恍神，或者过目即忘，就是应该休息的时候。当你错过某些重点是，请放慢脚步，否则将失去更多。 用心感受 必须让大脑知道这一切很重要。试着融入故事情景，为照片加上自己的说明，即使是抱怨笑话不太好笑，都比毫无感觉更好。任何情绪反应对学习效果都有帮助。 动手吧 学习编程只有一种方式：试着多多设计这种语言的代码。","tags":[{"name":"学习","slug":"学习","permalink":"http://qianniuer.github.io/tags/学习/"},{"name":"方法","slug":"方法","permalink":"http://qianniuer.github.io/tags/方法/"}]},{"title":"《你的剧本逊毙了》","date":"2014-11-09T05:27:59.000Z","path":"2014/11/09/《你的剧本逊毙了》/","text":"写那些让你深深着迷欲罢不能的东西，那些让你血液沸腾，让你午夜难以入眠，让你在鸡尾酒会上不顾场合热烈争论，甚至不惜和老友闹翻的东西。“ 写剧本将改变你的人生 ， 就算你不能卖掉它 ， 最起码你改变了你的人生 。 ”——约翰·特鲁比 你现所写的东西在深深吸引别人之前，是否深深吸引着你自己？可能已经深藏于表之下的十七层底，你笔下的故事是不是终究还是围绕某个吸引你的核心的？如果你有什么想说 ，那你的剧本就值得一读 。写作不适合懦夫，它需要投入巨大的心力和精力，艰苦卓绝。从事这项工作段时日，你就会被痔疮、背痛缠身。如果你一心只想着挣钱，你绝对没法捱过漫长过程中深入骨髓的艰难困苦。所以，看在上帝的份上，你得确实有什么想写才行。你为什么想要写作？你为什么充满激情？对你来说什么东西重要？什么是能写的，你关心的，你所知的，读者有兴趣看的？什么故事你比其他任何作者更有资格说？如果因为之前七部冲浪惊悚片都赚了一笔，所以你也要写一部冲浪者的惊悚片，那从一开始你写作的目的就是错的。而敏锐的观众也能闻到这种从内而外散发出来的坏疽的腐臭味。你可以写这个世界上最愚蠢的电影 —— 如果其中确实有什么东西仿佛钩子勾着你的内脏 —— 你终于有机会写点与众不同的东西了。 制片人也跟观众一样。他们只有等你给他们的时候，才知道他们想要什么 。所以赶紧把你独特的东西展示给他们吧。 你的人生也许并不是上好的电影题材，所以一定要注意把它改编成戏剧，然后应深深挖掘你的内心，发掘出那种深埋的情绪。你可以就自己的感受写一部了不起的电影，强烈的情感是全宇宙通吃的，也会像流沙一样深深吸住你的读者，让他们沉溺其中不可自拔。 尽一切方法，利用一切手段，为你的影片找到一个好名字。 你的人物是个百分百的好人么？没人应该这样。他们得有一到两个缺点。 人物一定要是可见的 ，即使把声音关掉也一样 。眼见一个家伙把蔬菜罐头洗了再洗才放进储藏室，效果远胜于听他说： “ 我是个洁癖怪人 。” 你的人物有变化么？变化越大，就可能越好写。在114页的剧本里，如果托比是从A一路变成Z，想想其中有多少步你可以写。但是如果他只是从 A 到 F ，变化没那么大，写作难度也增加了。 没有所谓的“一个普通小镇”，没有所谓的“一个中等城市”，真实生活中也许没有，电影里是肯定没有。如果你在选择地点的时候不能做到真正的具体 ， 具体到乡村、城市或者别墅里的某个房间，你就没法发挥到最佳写作水平。 你的故事发生在哪一年最合适？哪个季节最合适？想象一下你的故事发生在罗马、发生在冬日里积雪三尺厚的死寂的阿拉斯加，或者发生在加利福尼亚的海滩上会多么巨大的不同？观众对同一个事件分别发生在内布拉斯加州、塞尔玛或阿拉巴马又会有怎样不同的反应？地点的选择不仅会影响整个故事，还会影响单个的场景。 他可以是全宇宙无敌的超级混蛋 ， 但只要他有趣 ， 我们照样会被他吸引 。 我们希望你笔下的人物得到他想要的，但是我们不必喜欢他，我觉得最好的状态就是：“他是我们最讨厌的家伙，我们却偏偏仍希望他赢 。 ” 你必须为英雄找到一个人来对抗。如果你没有，赶紧找一个。 你的英雄是否有趣，取决于他的对手。 别把他弄成一个百分百的坏蛋。就像你的英雄也不是百分百的好人一样 ， 你的对手也不应该是一个彻底的混蛋 。 没有对手，你的英雄永远也不可能进化到他需要变成的那样。 是什么引起主人公发生变化？最好是他的对手。 人物和故事优先 ， 先于任何事情 。把结构扔到一旁，先享受故事的乐趣。 那是我最富有创造力的时刻之一，曾经，在一个午后，我躺在床上，胸前口袋里揣着一个录音机。在我渐渐进入梦乡之前 ，我一直听着音乐构思故事。真正进入睡眠之前我仿佛遁入了一个奇妙的空间——我依然可以思考可以说话，我的思维和音乐互动不受约束——那种自由的感觉简直难以置信。想法自己就飞旋着跑出来，而我只是把这些由音乐触发的想法口述出来。 我迫使自己一直醒着，坚持停留在这个不受正常思维拘束的区间，就在半梦半醒之际对着录音机讲述——直到最后渐渐睡去。当我从小憩中醒来，就开始誊写自己的笔记。一些很垃圾，但是另一些非常有创造力。这是一种构思故事的非常方法，仅供参考。 作为一个编剧你追求的就是张力。 不要犯我很多学生都犯的错误，故事一开始的时候就缺乏张力——赌注不能一开始很低，到后面才提高；赌注要一开始就很高，然后越来越高，越来越高。一开始的时候，你的家伙已经在走钢丝了，然后在他走到半途的时候开始刮风，他的老婆远远地站在钢丝那头对他嚷嚷要离他而去。当他走到3/4的位置的时候，他的医生给他掷过来一只纸飞机，打开是张便条，为了告诉他得了癌症 ……不管怎样 ， 反正不能让你的家伙一开始的时候稳稳当当地站在地下 ， 故事必须一开始就张力十足。 你的时间期限压缩得越短 ， 就越容易得到令人满意的好故事 ， 因为你给你的人物增加了困难。 给读者提供一次情感经历，否则你就是在浪费时间。什么情感不要紧，但是一定要确保他或她确实感受到了,当然越强越好。 你的故事必须围绕某事——这就是你的主题。在电脑上把它打出来，一直盯着它。不管你的主题是什么，你的英雄需要从始至终都在解决这个问题 ， 他的性格成长也必须与主题紧密结合 —— 这是故事结构的基础。 “一个能引起共鸣（或引人注目）的主人公发现自己身处于某种麻烦之中，他做一些积极的努力试图摆脱这麻烦，然而他的每一次努力 ， 只能让他陷得更深 ，而且一路上他遭遇的阻碍也越来越大。最后，当事情看起来好像最黑暗无望的时候 ， 主人公好像就要玩完了的时候 ， 通过他自己的力量 、 智慧或者机灵 ， 他终于设法摆脱了麻烦 。 ” 这个麻烦也需要像主人公一样有趣。不仅仅只是对你有趣！它必须是一个有相当难度的大问题，而且很激烈。如果她不能解决，之后的人生就会一团糟。 永不言弃！这是你的英雄的颂歌，也是不解的魔咒！ 阻碍必须越来越大，只有这样，通过跟它们的战斗，人物才能变得越来越聪明越来越强大，最终才能战胜坏蛋。更重要的一个原因是 ， 如果阻碍不是越来越大的话，读者就会觉得乏味失去兴趣。 不管你写什么怎么写 ， 反正你必须让他走到悬崖边上 ， 差点就摔得粉碎一命呜呼。 你必须知道你的人物一开始的时候在哪儿，你还必须知道你的人物最终要去哪儿，这就是她的弧光、她的转变、她的变化。有时你可以先想结尾：“当一切结束的时候，她会是什么样子？——强壮，友善，活跃？”然后反向进行——“那她开始的时候是怎样一个人？ —— 脆弱，烦躁，处境危险？ ” 如果你从头娓娓道来你的英雄是如何陷入困境 ，效果估计不会理想，一开场就该让他正身处困境之中。如果他没有麻烦 ， 你干吗要讲这个故事？给他一个够分量的、困难的、有趣的问题。 故事一开头人物没有意识到的东西，到故事结尾却是人物真正需要的东西。米克和基思所言极是——“你不是总能得到你想要的 ” ， 但是如果你努力 （ 真的很努力 ！ ） ， “ 你会得到你需要的 ” 。 在中间点（midpoint）也需要有一个大事件。或者人物大胜，或者人物惨败。或者让我们觉得美妙绝伦，或者让我们觉得糟糕透顶。总之有什么事发生 ，故事由此拐入新的方向。布置个作业，随便挑些电影，找出影片的中间点。瞧 ，它在那儿！ 最低限度你需要知道你的主题、你的人物怎样转变，故事中主要的惊喜是什么。当然你还需要知道结尾，知道你要往哪儿去很重要 。 “一句话大纲”是非常重要的写作工具！没有它根本不可能看到你的故事，比如看115页的剧本很难看清楚故事的情节设置。通过把每个场景里发生的事只用一句话做言简意赅的描述，你就可以将故事的全貌一览无遗。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://qianniuer.github.io/tags/笔记/"},{"name":"剧本","slug":"剧本","permalink":"http://qianniuer.github.io/tags/剧本/"},{"name":"读书","slug":"读书","permalink":"http://qianniuer.github.io/tags/读书/"}]},{"title":"《拒绝平庸（周鸿祎和他的创世记）》","date":"2014-10-31T13:45:40.000Z","path":"2014/10/31/《拒绝平庸（周鸿祎和他的创世记）》/","text":"《拒绝平庸》，这本书是360创始人周鸿祎的传记。不久前读完了这本书，做了一些笔记，和大家共勉： 1、未来10~15年，你到底想要成为什么样的人？未来10~15年，你到底最想获得什么？这是最重要的。这个东西，你可以说是梦想，也可以说是价值观。为什么？因为一旦想清楚了，以后你无论作什么判断，作什么选择，就都简单多了。有助于实现我梦想的，我就干；没帮助，我就放弃。把梦想锚定，短期内不管你遇到什么诱惑，遭遇什么困难，都不会左右你的判断和选择。 2、只有这种非利益化的梦想和目标，才能长期激励一个人不断地去追求。 3、创业其实是一种精神，是一种心态。创业有很多种形式，不是只有自己办公司，自己当老板才叫创业。当你的人生还处于起步阶段，你不具备足够的经验和能力，就要给人当学徒，需要学习和积累，其实这个过程也是创业。4、说真话，也许日子会难过一时，但造假，却可能一辈子抬不起头。 5、这个世界上总是凡人多，既然是凡人，便有凡人的毛病，你有，别人也会有。 6、创业和打工都只是一种生活方式，没有高低优劣之分，只看是否适合自己。 7、被激发起来的热情最后变成什么——是焰火般绚烂后归于沉寂，还是浓缩成一团心火，温暖你仰望星空时的梦想，也照亮你蹒跚前行的路？ 8、如果你见都没见过，模仿都谈不上，怎么可能谈创造呢？ 9、真正的视野开阔，要靠那些过了脑子再过心最后留下来的东西。 10、你能投机，别人就能取巧，如果一点儿技术壁垒都没有，做什么都是无法长久的。 11、一个优秀的人必定会有其他优秀的人主动来进行价值交换。专注于理想；独善其身并亲近那些独善其身的人。 12、信息，沟通，眼光。 13、因为籍籍无名，所以可以犯错。 14、唯有学习和反思才能让人避免下次再犯同样的错误。 15、优秀要靠专注地积累能量。 16、看到别人做出一款软件，他就会想：如果我做，我会怎么做。尽管他没有真正去做这些项目，但是相当于沙盘推演了一遍。他不断寻找这样的问题，跟团队、同学和认识的相关的人去讨论。 17、卡氏16种人格测试。 18、两类人创业不容易成功，一种是技术人员，一种是文人，因为这两种人都特别自负。 19、谁能想到方正、雅虎、诺基亚的没落？未来不可预知，没有什么不可能，时间就是最好的武器。 20、想要，就着手做点儿什么。 21、有所为，有所成，必然有所不为，有所不成。 22、罗伯特·弗罗斯特：林中有两条路，你永远只能走一条，怀念着另一条。 23、用户至上，创新，创业精神。 24、商业模式无论怎样千变万化，用户基础才是王道。 25、免费是互联网之本。 26、做好产品，服务消费者才是根本，用谁的技术、用什么技术都是手段而已。 27、乔布斯：微小的的创新可以改变世界。周鸿祎：改变数字工业的革命，并不是高瞻远瞩、行思缜密的战略规划使然，而是微创新的必然结果。 28、苹果也好，360也好，微创新一定从冷门开始，从大公司不注意的角落开始，凭着经验和直觉去把握每一步，没有战略规划，每一件事都是做成了再总结。 29、创业精神在人生的每一个阶段都是需要的，其核心就是：为自己奋斗。 30、华为创始人任正非。 31、最重要的是：你在360能不能学到东西，能不能锻炼出能力。 32、做公司很容易，把公司做成功很难。 33、用心，外行也能成为专家。 34、多读书、多看报、多与其他人交流，用外来的崭新的思维力量打破条条框框。 35、看报纸杂志的时候，少看行业高端杂志，多看面向普通用户的杂志。多读这样的刊物，就能帮助你从用户的角度出发看问题。 36、对于优秀的产品经理来说，改善用户体验的机会无处不在。当你走出办公室，你就是其他产品的用户，但你不要做一个抱怨的用户，而要提升一个层次，抱怨完了，想一想其他人是不是像你一样在抱怨，你应该怎么为其做出改善。 37、脸皮厚，不怕骂，没心没肺。 38、YY创始人李学凌。 39、一个人做不了太多事，所以在一点上做到极致，反而找到了简单而锋利的武器。 40、做产品得先考虑怎么让用户满意，让用户觉得舒服，而不是现在怎么挣钱。 41、商业模式不是盈利模式，它包含着盈利模式。盈利模式是商业模式的最后一步，是商业模式一步步发展成熟后水到渠成的结果。 42、商业模式的核心是产品，本质是通过产品为用户创造价值。 43、商业模式：产品模式 -&gt; 用户模式 -&gt; 推广模式 -&gt; 收入模式。 44、他们用你的产品用的好，那是理所当热，很少站出来表扬你。但你一旦用得不爽，就会骂你。 45、hao123和4399创始人李兴平，初中毕业。 46、尤费《柔道战略》。 47、流程再造。 48、哈默《超越再造》、《企业行动纲领》 49、李安：每个人的心中都藏龙卧虎。 50、团队应该像磨石机中的石头一样，碰撞，争论，大吵，不怕有冲突，最后才能产生好的想法。 51、如果你觉得自己是A级人才，你觉得自己很棒，那你的自尊心不需要领导来呵护。 52、管理的目的：服务，所有的管理流程都应该为公司的业务服务。 53、《硅谷热》、《创业的国度》 54、最大的成就就是帮助别人成功，最赚钱的事就是帮助别人赚钱。 55、狼性文化 56、向苹果学习颠覆精神。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://qianniuer.github.io/tags/笔记/"},{"name":"读书","slug":"读书","permalink":"http://qianniuer.github.io/tags/读书/"},{"name":"周鸿祎","slug":"周鸿祎","permalink":"http://qianniuer.github.io/tags/周鸿祎/"}]},{"title":"程序员笑话之极品对答","date":"2014-07-06T07:29:35.000Z","path":"2014/07/06/程序员笑话之极品对答/","text":"原文来自：http://www.itjhwd.com/cxyxhdd/ A：嘿 //是什么意思啊？B：嘿.A：呃 我问你//是什么意思？B：问吧.A：我刚才不是问了么？B：啊？A：你再看看记录…B：看完了.A：……所以//是啥？B：所以什么？A：你存心耍我呢吧？B：没有啊 你想问什么？……不断循环之后，A一气之下和B绝交，自己苦学程序。N年之后，A终于修成正果，回想起B，又把聊天记录翻出来看，这时，他突然发现B没有耍他……而他自己也不知道当年他问B的究竟是什么问题…… 程序员问禅师：“大师，我身体健康思想端正，各方面都不错，为何没有女朋友？”禅师笑答：“原因很简单，不过若想知道，需先写一段java代码。” 青年略一沉吟，写完了。“再写一段C#。” 写完了。“再写一段php。” 写完了。“这就是原因” 老婆给当程序员的老公打电话：“下班顺路买一斤包子带回来，如果看到卖西瓜的，就买一个。”当晚，程序员老公手捧一个包子进了家门……老婆怒道：“你怎么就买了一个包子？！”老公答曰：“因为看到了卖西瓜的。 男：第一个问题：对于我第二个问题和第三个问题可不可以用 “能 ”和 “ 不能 ”回答？女：当然可以啊！男：第二个问题：对于我第三个问题是你能不能做我的女朋友，能不能和第二个问题答案一样？女：能….男：第三个问题：你能不能做我的女朋友？女：不能啊.男：你言而无信啊.. 你对于我的第二个问题是能的.女：那好，你的第二个问题我回答 不能！！！.男：好的，我第三个问题：你能不能做我女朋友？女：不能！！！男：你又骗人，刚对于我的第二个问题回答 不能的，怎么第二个问题答案和第三个问题答案一样？ 昨天晚上下班回家，一民警迎面巡逻而来。突然对我大喊：站住！民警：int类型占几个字节？我：4个。民警：你可以走了。我感到很诧异。我：为什么问这样的问题？民警：深夜还在街上走，寒酸苦逼的样子，不是小偷就是程序员。 面试官：知道什么叫类么？应聘者：我这人实在，工作努力，不知道什么叫累。面试官：知道什么是包？应聘者：我这人实在，平常不带包，也不用公司准备了。面试官：知道什么是接口吗？应聘者：我这个人工作认真，从来不找借口偷懒。面试官：知道什么是继承么？应聘者：我是孤儿没什么可以继承的。面试官:知道什么叫对象么？应聘者:知道，不过我工作努力，上进心强，暂时还没有打算找对象。面试官：知道多态么？应聘者：知道，我很保守的。我认为让心爱的女人为了自已一时的快乐去堕胎是不道德的行为！请问这和C#有什么关系？？ 街边，一对情侣在吵架。女孩对男孩说，“我们分手吧！”男孩沉默半天，开口问道，“我能再说最后一句话吗？”“说吧，婆婆妈妈的。”“我会编程……”“会编程有个屁用啊，现在到处都是会编程的人！”男孩涨红了脸，接着说道，“我会编程……我会变成……童话里,你爱的那个天使……”","tags":[{"name":"程序员","slug":"程序员","permalink":"http://qianniuer.github.io/tags/程序员/"},{"name":"笑话","slug":"笑话","permalink":"http://qianniuer.github.io/tags/笑话/"}]},{"title":"大学生十八条受益一生的定律","date":"2014-01-18T03:33:01.000Z","path":"2014/01/18/大学生十八条受益一生的定律/","text":"1、一定要有独立的人格、独立的思想。一个经过独立思考而坚持错误观点的人比一个不假思索而接受正确观点的人更值得肯定。不要成为灌输教育的牺牲品。 2、仕途，商界，学术。大致说来，每个人都注定要走上三条道路中的某一条。在进行职业生涯规划的时候，不妨以此作为思考的出发点。根据不同的职业生涯规划来塑造各自的核心竞争力。只有知道自己以后要做什么，才能知道自己应该学什么。 3、专业无冷热，学校无高低。没有哪个用人单位会认为你代表了你的学校或者你的专业。千万不要因为你是名牌大学或者热门专业而沾沾自喜，也大可不必因为你的学校不好或者专业冷门而自卑。 4、千招会，不如一招熟。十个百分之十并不是百分之百，而是零。如果你有十项工作每项都会做百分之十，那么，在用人单位眼中，你什么都不会。所以，你必须要让自己具备核心竞争力。“通才”只有在“专才”的基础上才有意义。 5、不逃课的学生不是好学生。什么课都不逃，跟什么课都逃掉没什么两样。一定要掌握学习的主动性，不要像读中学一样被老师牵着鼻子走。逃课没有错，但是不要逃错课。同时，既要逃课，又要让老师给高分。 6、一定要学会理财。对于贫困生来说，首先要做的不是挣钱，而是省钱。很多大学生读书的时候一掷千金，可是，毕业以后一个月的工资还不够交半个月的房租。 7、掌握必要的计算机操作能力。大部分女生将电脑当成了影碟机，大部分男生将电脑当成了游戏机。大学生要掌握必要的计算机操作能力，但是，很多时候电脑会成为浪费时间的堂而皇之的借口。有电脑的大学生非常多，可是，这中间很多人可能大学毕业的时候还不会Excel，不会做一个像样的PPT。 8、做事不如做人，人脉决定成败。一个人有多少钱并不是指他拥有多少钱的所有权，而是指他拥有多少钱的使用权。一个人具备多少能力，不只是说他一个人的时候能做什么，还包括他能通过别人做什么。一个人赚的钱，12、5%是靠自身的知识，87、5%则来自人脉关系。三十岁以前靠专业赚钱，三十岁以后拿人脉赚钱。所以，请好好珍惜大学期间建立起来的人脉关系。这几年你认识的朋友可能会是你毕业以后最可宝贵的财富。 9、互联网固然威力无穷，但是，如果你沉迷于网络聊天，或者沉迷于网络游戏，浪费的金钱倒是可以弥补，荒废的青春就无可追寻了。轻舞飞扬已经红颜薄命了，而痞子蔡却继续跟别的女孩发生着一次又一次的亲密接触。对于很多大学生而言，网吧就是一个血淋淋的黑洞。 10、爱情是不期而至的，可以期待，但不可以制造。花开堪折方须折，莫让鲜花败残枝。一个有一万块钱的人为你花掉一百元，你只占了他的百分之一；而一个只有十块钱的人为你花掉十块，你就成了他的全部。 11、不要以为考研究生就是积极进取的表现。研究生扩招的速度是30%，也就意味着硕士学历贬值的速度是30%。对于很多人而言，考研不过是一种消极逃避的方式罢了。对于绝大多数人而言，读研究生纯粹是浪费时间浪费金钱，立志从事科研、学术的人及其他少数人除外。 12、不要一门心思想着出国，更加不要迷信外国的月亮比中国圆。削尖脑袋记GRE词汇很可能是一件非常愚蠢也非常可悲的事情。既然全世界的公司都想到中国的市场上来瓜分蛋糕，为什么中国人还要一门心思到国外去留学然后给外国人打工？ 13、人才市场就是一个地雷阵。通过多种方式求职固然没有错，但是千万不要饥不择食。只要用人单位一说要你交钱，你掉头就走便是了。 14、求职简历必须突出自己的核心竞争力。 15、垃圾是放错位置的人才。所以，在找工作的时候一定要把自己放到那个让你成为人才而不是垃圾的职位上。当然，前提是你要知道自己究竟想做什么、究竟适合做什么。世界上最大的悲剧莫过于有太多的年轻人从来没有发现自己真正想做什么。骑驴找马固然没错，可是，并非随便找一头驴就能找到千里马。所以，一定要重视第一份工作。 16、大公司是做人，小公司是做事。进入公司工作以后，必须尽快融入写字楼政治。职员能否得到提升，很大程度不在于是否努力，而在于老板对你的赏识程度。在写字楼的政治斗争中，一定要学会自我保护。 17、瘦死的骆驼比马大。撑死胆大的，饿死胆小的。一定要有创业的勇气和魄力。如果你一直满足于给别人打工，那么，不管你工资多高，永远都只能是一个可怜的穷光蛋。就算月薪2万，在深圳上海那种地方，一年的存款还买不来一个小小的洗手间。 18、大学期间一定要多去图书馆多去自习室。很多书你现在不读，一辈子就再也没有机会去读了。虽然不是每本书看了都一定有用，但是，因为你不知道究竟哪本书以后会有用，所以只好多看书，并且抛弃那些过于功利的想法。尽管每次网到鱼的不过是一个网眼，但要想捕到鱼，就必须要编织一张网。","tags":[{"name":"励志","slug":"励志","permalink":"http://qianniuer.github.io/tags/励志/"},{"name":"语录","slug":"语录","permalink":"http://qianniuer.github.io/tags/语录/"}]}]