[{"title":"","date":"2017-04-02T08:03:11.952Z","path":"2017/04/02/JavaScript中this指向/","text":"JavaScript中this指向 对于JavaScript初学者来说，this指针的指向问题一直是很混乱的问题。在不同的场景下，this会化身不同的对象。有一种观点认为，只有正确掌握了JavaScript 中的 this 关键字，才算是迈入了 JavaScript这门语言的门槛。在主流的面向对象的语言中（例如Java,C#等)，this 含义是明确且具体的，即指向当前对象。一般在编译期绑定。而JavaScript 中this 在运行期进行绑定的，这是JavaScript 中this 关键字具备多重含义的本质原因。 随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。 1、 指向window的隐式指向12345function sayHello()&#123; this.name = \"tsrot\"; console.log(\"hello \" + this.name);&#125;sayHello() //hello tsrot 此时的变量name相当于window.name，因为调用sayHello函数的对象为window，相当于window.sayHello()。和下面两种情况是一样的：12345var name = \"tsrot\";function sayHello()&#123; console.log(\"hello \" + this.name);&#125;sayHello(); //hello tsrot 下面的name相当于在window下赋值了两次，谁后面执行就取谁。如果把var name = “xieliqun”放到sayHello（）后面，此时输出的就是 hello xieliqun。123456var name = \"xieliqun\";function sayHello()&#123; this.name = \"tsrot\";&#125;sayHello(); console.log(\"hello \" + this.name); //hello tsrot 注：当函数在DOM上调用时，未传入this，此时，this也指向window。当传入this时，this指向当前DOM input，例如下面情况：123456&lt;input type=\"button\" value=\"click me\" onclick=\"sayHello()\"&gt;&lt;script&gt; function sayHello()&#123; console.log(\"hello \" + this.tagName); //hello undefined &#125;&lt;/script&gt; 123456&lt;input type=\"button\" value=\"click me\" onclick=\"sayHello(this.tagName)\"&gt;&lt;script&gt; function sayHello(tagName)&#123; console.log(\"hello \" + tagName); //hello INPUT &#125;&lt;/script&gt; 2、 指向当前对象的显式调用（1）、作为对象方法的调用函数还可以作为某个对象的方法调用，这时this就指这个上级对象。1234567function sayHello()&#123; console.log(\"hello \" + this.name);&#125;var o = &#123;&#125;;o.name = \"tsrot\";o.hello = sayHello;o.hello(); //hello tsrot （2）、作为构造函数调用所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。12345function sayHello()&#123; this.name = \"tsrot\";&#125;var o = new sayHello();console.log(\"hello \" + o.name); //hello tsrot 3、 指向当前对象的隐式调用（1） call、apply调用call（）、apply()都是函数对象的一个方法，它们的作用是改变函数的调用对象，它们的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。1234567function sayHello()&#123; console.log(\"hello \" + this.name);&#125;var o = &#123;&#125;;o.name = \"tsrot\";o.hello = sayHello;o.hello.apply(); //hello apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。如果把最后一行代码修改为12345// o.hello.apply(); //helloo.hello.apply(o); //hello tsroto.hello.apply(this); //hello tsroto.hello.call(o); //hello tsroto.hello.call(this); //hello tsrot 此时this就指向对象o了。 （2） 原生Function方法bind（）调用很多人不知道原生js也有bind（）方法，一直以为bind（）的方法只有jQuery有，我也是最近看别人博客知道的。其实原生的bind和jQuery的bind是不同的，原生的bind相当于apply和call。12345678var person = &#123; name:\"tsrot\", sayHello:function()&#123; console.log(\"你好，我是\"+this.name); &#125;&#125;var boundFunc = person.sayHello.bind(person,person.sayHello);setTimeout(boundFunc,5000); //5秒后输出 你好，我是tsrot ,[setTimeout 涉及一些执行栈的问题](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout)，或者简单的理解,在浏览器中setTimeout是window的属性。 下图代码中person.sayHello,相当于在window.person.sayHello，所以this指向window。12345678var person = &#123; name:\"tsrot\", sayHello:function()&#123; console.log(\"你好，我是\"+this.name); &#125;&#125;//var boundFunc = person.sayHello.bind(person,person.sayHello);setTimeout(person.sayHello,5000); //5秒后输出 你好，我是 用apply和call调用时，函数将立即执行12345678var person = &#123; name:\"tsrot\", sayHello:function()&#123; console.log(\"你好，我是\"+this.name); &#125;&#125;var boundFunc = person.sayHello.apply(person,person.sayHello);setTimeout(boundFunc,5000); //立即输出 你好，我是tsrot 4、 当this在构造函数有return时如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。123456function fn()&#123; this.name = \"tsrot\"; return &#123;&#125;;&#125;var o = new fn();console.log(o.name); //undefined 123456function fn()&#123; this.name = \"tsrot\"; return function()&#123;&#125;;&#125;var o = new fn();console.log(o.name); //undefined 当return null和undefined时123456function fn()&#123; this.name = \"tsrot\"; return null;&#125;var o = new fn();console.log(o.name); //tsrot 123456function fn()&#123; this.name = \"tsrot\"; return undefined;&#125;var o = new fn();console.log(o.name); //tsrot","tags":[]},{"title":"","date":"2017-04-02T08:03:11.933Z","path":"2017/04/02/React学习资源汇总/","text":"React学习资源汇总博客地址：http://blog.xieliqun.com/2016/11/05/react-study/ React是如今最热门的前端框架，它设计思路独特，性能卓越，逻辑简单，受到了广泛开发者的喜爱。一旦接触她，你就会被她深深吸引。我断断续续的学了将近两个月，今天终于有时间把自己学习React的一些学习资料总结一下。 React 官方 官网地址：http://facebook.github.io/react/ Github地址：https://github.com/facebook/react 设计思想学习React之前，我们先了解一下它的设计思想，它与如今其他热门的前端框架有什么不同？它能为我们的开发解决哪些痛点？ React 设计思想 React的设计哲学 - 简单之美 颠覆式前端UI开发框架:React 初学者入门文章可以结合一些简单demo去看文章，例如你在看阮一峰的React 入门实例教程时，可结合他写的入门demo，或官方给的demo。当然你也要边学习边自己去写一些简单demo，去改改别人写的一些React 项目。一定要多动手。 React 入门实例教程-阮一峰：建议先看demo 一看就懂的ReactJs入门教程（精华版） React 教程-菜鸟教程：安装那节好像有点错 React 入门，5个常用DEMO展示 如何学习React 给新手的 React&amp;Webpack 上手教程 ReactJS 傻瓜教程 React 最简单的入门应用项目 入门 demo 官方入门 demo：可结合官方的入门文档 入门 demo-阮一峰：结合入门文章 模仿知乎界面的一个简单React demo：结合 ReactJS中文基础视频教程-爱酷 入门视频教程一定要边看边写，不要囫囵吞枣的看一遍就好了。 React入门-慕课网 ReactJS中文基础视频教程-爱酷 ReactJS中文视频教程 React教程- 汇智网 入门实战视频了解React开发流程，作者的编码思路，写作规范。 React实战–打造画廊应用（上） React实战–打造画廊应用（下） ReactJS中文基础视频教程 构建实时聊天应用 开发文档开发其实不用详细去全看，在你做项目时，遇到不懂的就去查看一下文档，我认为这样效率更高一点。当然你有时间也可以一步步去阅读。 官方文档 中文文档 学习网站在学习中我们会遇到 一些问题，可以去社区或一些网站寻找答案，下面推荐一些好的React 社区和学习网站。 React中文社区 React 中文索引 React知识库 A quick start to React stack overflow 知乎 React 话题 segmentfault React 话题 React技术栈React是一款非常优秀的前端框架，你要发挥它完全的性能，你就要结合其他一些技术，例如webpack、redux、react-router等。 React 技术栈系列教程 百度母婴技术团队—基于Reactjs实现webapp Building a React Universal Blog App React为啥非得使用immutable.js React Server Side Rendering 解决 SPA 应用的 SEO 问题 webpack官方文档 Webpack 中文指南 webpack一小时快速入门 使用webpack轻松构建你的第一个react开发框架 入门Webpack，看这篇就够了:写的很不错，逐级深入，适合入门，有点长，耐心看完 react-router React Router 中文文档 React Router 官方 demo Redux官网 Redux 中文文档 Redux 官方 demo Redux 莞式教程 Redux 视频教程 redux 大法好 Flux 傻瓜教程 react+redux渲染性能优化原理 React开发社区 数据流管理架构之 Redux 介绍 React同构直出优化总结 前端路由实现与 react-router 源码分析 如何开发一个 Webpack Loader ( 一 ) 服务器端渲染实践小结 听说你需要这样了解 Redux 学习Redux刷新了我的前端App状态管理观 Learn React &amp; Webpack by building a hacker news front page 开发工具 react-devtools React DevTools 正式发布，完全支持 React Native redux-devtools Redux超酷的开发工具Redux-Devtools redux 常用中间件或工具 redux-thunk redux-gen redux-undo react-router-redux react-redux-form React 开源项目介绍一些国内外比较好的 React 开源项目。 国内： 阿里的 React 组件库 Ant Design 简易留言板 react-zhihu React的扫雷游戏 在线聊天室 使用React技术栈开发SPA 阔论留言评论 React版cnode社区 适合新手学习的Demo， React + react-router + webpack + babel + Node + express + mongodb 国外： Relax SoundRedux Gatsby isomorphic500 NuclearMail Picard React Color Sentry react-hn Perseus","tags":[]},{"title":"AJAX工作原理","date":"2016-04-16T08:37:46.000Z","path":"2016/04/16/Ajax工作原理/","text":"&gt; AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 一、ajax所包含的技术 大家都知道ajax并非一种新的技术，而是几种原有技术的结合体。它由下列技术组合而成。 使用CSS和XHTML来表示。 使用DOM模型来交互和动态显示。 使用XMLHttpRequest来和服务器进行异步通信。 使用javascript来绑定和调用。 在上面几中技术中，除了XmlHttpRequest对象以外，其它所有的技术都是基于web标准并且已经得到了广泛使用的，XMLHttpRequest虽然目前还没有被W3C所采纳，但是它已经是一个事实的标准，因为目前几乎所有的主流浏览器都支持它。 二、怎样创建ajaxAjax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。原生创建ajax可分为以下四步。 1、创建XMLHttpRequest对象所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。创建 XMLHttpRequest 对象的语法：1var xhr = new XMLHttpRequest(); 老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象：1var xhr = new ActiveXObject(\"Microsoft.XMLHTTP\"); 为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ：123456var xhr;if(XMLHttpRequest)&#123; xhr = new XMLHttpRequest();&#125;else&#123; xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");&#125; 2、准备请求初始化该XMLHttpRequest对象，接受三个参数：1xhr.open(method,url,async); 第一个参数表示请求类型的字符串，其值可以是GET或者POST。GET请求：1xhr.open(\"GET\",demo.php?name=tsrot&amp;age=24,true); POST请求：1xhr.open(\"POST\",demo.php,true); 第二个参数是要作为请求发送目标的URL。第三个参数是true或false，表示请求是以异步还是同步的模式发出。（默认为true，一般不建议为false） false：同步模式发出的请求会暂停所有javascript代码的执行，知道服务器获得响应为止，如果浏览器在连接网络时或者在下载文件时出了故障，页面就会一直挂起。 true：异步模式发出的请求，请求对象收发数据的同时，浏览器可以继续加载页面，执行其他javascript代码 3、发送请求1xhr.send(); 一般情况下，使用Ajax提交的参数多是些简单的字符串，可以直接使用GET方法将要提交的参数写到open方法的url参数中，此时send方法的参数为null或为空。 GET请求：12xhr.open(\"GET\",demo.php?name=tsrot&amp;age=24,true);xhr.send(null); POST请求：如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定您希望发送的数据：123xhr.open(\"POST\",demo.php,true);xhr.setRequestHeder(\"Content-Type\",\"application/x-www-form-urlencoded;charset=UTF-8\");xhr.send(\"name=\"+userName+\"&amp;age=\"+userAge); 4、处理响应12345xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; console.log(xhr.responseText); &#125;&#125; onreadystatechange 事件：当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当 readyState 改变时，就会触发 onreadystatechange 事件。 readyState属性：0：已经创建对象，但还没有调用open()方法。1：已经调用open()方法，但还没有发送请求。2：请求已经发送，标题和状态已经收到，并可用。3：接收到来自服务器的响应。4：接收完请求数据，表示已经完成请求。 status属性：200:”OK”404: 未找到页面 responseText：获得字符串形式的响应数据responseXML：获得 XML 形式的响应数据返回值一般为json字符串，可以用JSON.parse(xhr.responseText)转化为JSON对象。 5、完整例子demo.html123456789101112131415var xhr;if(XMLHttpRequest)&#123; xhr = new XMLHttpRequest();&#125;else&#123; xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");&#125;;xhr.open(\"GET\",\"./data.json\",true);xhr.send();xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; console.log(JSON.parse(xhr.responseText).name); &#125;&#125; data.json1234&#123; \"name\":\"tsrot\", \"age\":24&#125; 三、ajax应用场景 场景 1. 数据验证 场景 2. 按需取数据 场景 3. 自动更新页面 四、ajax优缺点优点：1、页面无刷新，用户体验好。2、异步通信，更加快的响应能力。3、减少冗余请求，减轻了服务器负担4、基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。 缺点：1、ajax干掉了back按钮，即对浏览器后退机制的破坏。2、存在一定的安全问题。3、对搜索引擎的支持比较弱。4、破坏了程序的异常机制。5、无法用URL直接访问。","tags":[{"name":"原理","slug":"原理","permalink":"http://qianniuer.github.io/tags/原理/"}]}]